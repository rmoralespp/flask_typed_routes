{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"About flask_typed_routes is a Python library designed to validate Flask requests effortlessly with Pydantic . Features Type Safety: Automatically validates request parameters based on type annotations. Easy Integration: Simple Flask extension for applying validation to Flask routes. Error Handling: Automatically returns meaningful error responses for validation failures. Requirements Python 3.10+ Pydantic 2.0+ Flask Installation To install flask_typed_routes using pip , run the following command: pip install flask_typed_routes Getting Started Example of a simple Flask application using flask_typed_routes : Create a file posts.py with: import flask import flask_typed_routes as flask_tpr app = flask.Flask(__name__) flask_tpr.FlaskTypeRoutes(app) @app.route('/posts/<user>/') def read_user_posts(user: str, skip: int = 0, limit: int = 10): # Parameters not included in the \"path\" are automatically treated as \"query\" parameters. data = { 'user': user, 'skip': skip, 'limit': limit, } return flask.jsonify(data) Run the server with: flask --app posts run Data conversion: Open your browser and go to http://127.0.0.1:5000/posts/myuser/?skip=20 You will see the JSON response as: { \"limit\": 10, \"skip\": 20, \"user\": \"myuser\" } Data validation: Open your browser and go to http://127.0.0.1:5000/posts/myuser/?skip=abc You will see the JSON response with the error details because the skip parameter is not an integer: { \"errors\": [ { \"input\": \"abc\", \"loc\": [ \"query\", \"skip\" ], \"msg\": \"Input should be a valid integer, unable to parse string as an integer\", \"type\": \"int_parsing\", \"url\": \"https://errors.pydantic.dev/2.9/v/int_parsing\" } ] }","title":"Introduction"},{"location":"#about","text":"flask_typed_routes is a Python library designed to validate Flask requests effortlessly with Pydantic .","title":"About"},{"location":"#features","text":"Type Safety: Automatically validates request parameters based on type annotations. Easy Integration: Simple Flask extension for applying validation to Flask routes. Error Handling: Automatically returns meaningful error responses for validation failures.","title":"Features"},{"location":"#requirements","text":"Python 3.10+ Pydantic 2.0+ Flask","title":"Requirements"},{"location":"#installation","text":"To install flask_typed_routes using pip , run the following command: pip install flask_typed_routes","title":"Installation"},{"location":"#getting-started","text":"Example of a simple Flask application using flask_typed_routes : Create a file posts.py with: import flask import flask_typed_routes as flask_tpr app = flask.Flask(__name__) flask_tpr.FlaskTypeRoutes(app) @app.route('/posts/<user>/') def read_user_posts(user: str, skip: int = 0, limit: int = 10): # Parameters not included in the \"path\" are automatically treated as \"query\" parameters. data = { 'user': user, 'skip': skip, 'limit': limit, } return flask.jsonify(data) Run the server with: flask --app posts run Data conversion: Open your browser and go to http://127.0.0.1:5000/posts/myuser/?skip=20 You will see the JSON response as: { \"limit\": 10, \"skip\": 20, \"user\": \"myuser\" } Data validation: Open your browser and go to http://127.0.0.1:5000/posts/myuser/?skip=abc You will see the JSON response with the error details because the skip parameter is not an integer: { \"errors\": [ { \"input\": \"abc\", \"loc\": [ \"query\", \"skip\" ], \"msg\": \"Input should be a valid integer, unable to parse string as an integer\", \"type\": \"int_parsing\", \"url\": \"https://errors.pydantic.dev/2.9/v/int_parsing\" } ] }","title":"Getting Started"},{"location":"body/","text":"Request Body To declare a request body, you use Pydantic models with all their power and benefits Note By default, the library interprets a Pydantic model used as a type annotation in a function signature as a request body model. However, if you only want to validate specific fields in the request body, you can use the JsonBody() annotation. Basic Usage of request Body Validation: import typing as t import flask import pydantic import flask_typed_routes as flask_tpr app = flask.Flask(__name__) flask_tpr.FlaskTypeRoutes(app) class Item(pydantic.BaseModel): title: str author: str @app.post('/items/') def create_item(item: Item): # Use Pydantic model to validate the request body return flask.jsonify(item.model_dump()) @app.put('/items/<item_id>/') def update_item( item_id: int, title: t.Annotated[str, flask_tpr.JsonBody()] = None, author: t.Annotated[str, flask_tpr.JsonBody()] = None, ): # Use `JsonBody` to validate specific fields in the request body data = { 'item_id': item_id, 'title': title, 'author': author, } return flask.jsonify(data) Explanation: Item : Pydantic model that represents the structure of the request body. The model has two fields: title and author . create_item : Route that accepts a POST request with a JSON body that must match the Item model. update_item : Route that accepts a URL parameter item_id that must be an integer. The route also accepts two optional JSON body parameters: title and author . The parameters are validated using the library field JsonBody . Create a new Item Invalid request Body: POST http://127.0.0.1:5000/items/ { \"title\": \"Hello, World!\" } Http Response: { \"errors\": [ { \"input\": { \"title\": \"Hello, World!\" }, \"loc\": [ \"body\", \"author\" ], \"msg\": \"Field required\", \"type\": \"missing\", \"url\": \"https://errors.pydantic.dev/2.9/v/missing\" } ] } Update an Item Invalid request Body: PUT http://127.0.0.1:5000/items/123 { \"title\": 111 } Http Response: { \"errors\": [ { \"input\": 111, \"loc\": [ \"body\", \"title\" ], \"msg\": \"Input should be a valid string\", \"type\": \"string_type\", \"url\": \"https://errors.pydantic.dev/2.9/v/string_type\" } ] } Using multiple Pydantic Models, JsonBody Field with embed import typing as t import flask import pydantic import flask_typed_routes as flask_tpr app = flask.Flask(__name__) flask_tpr.FlaskTypeRoutes(app) class Item(pydantic.BaseModel): title: str author: str class User(pydantic.BaseModel): email: str age: int @app.post('/users/<user_id>/items/') def create_item_by_user( user_id: int, item: t.Annotated[Item, flask_tpr.JsonBody(embed=True)], user: t.Annotated[User, flask_tpr.JsonBody(embed=True)], ): # Use `JsonBody` with `embed=True` to validate nested specific fields in the request body data = { 'user_id': user_id, 'item': item.model_dump(), 'user': user.model_dump(), } return flask.jsonify(data) Request Body POST http://127.0.0.1:5000/users/123/items/ { \"item\": { \"title\": \"Hello, World!\", \"author\": \"John Doe\" }, \"user\": { \"email\": \"myemail@abc.com\", \"age\": 25 } } Http Response { \"item\": { \"author\": \"John Doe\", \"title\": \"Hello, World!\" }, \"user\": { \"age\": 25, \"email\": \"myemail@abc.com\" }, \"user_id\": 123 }","title":"Request body"},{"location":"body/#request-body","text":"To declare a request body, you use Pydantic models with all their power and benefits Note By default, the library interprets a Pydantic model used as a type annotation in a function signature as a request body model. However, if you only want to validate specific fields in the request body, you can use the JsonBody() annotation. Basic Usage of request Body Validation: import typing as t import flask import pydantic import flask_typed_routes as flask_tpr app = flask.Flask(__name__) flask_tpr.FlaskTypeRoutes(app) class Item(pydantic.BaseModel): title: str author: str @app.post('/items/') def create_item(item: Item): # Use Pydantic model to validate the request body return flask.jsonify(item.model_dump()) @app.put('/items/<item_id>/') def update_item( item_id: int, title: t.Annotated[str, flask_tpr.JsonBody()] = None, author: t.Annotated[str, flask_tpr.JsonBody()] = None, ): # Use `JsonBody` to validate specific fields in the request body data = { 'item_id': item_id, 'title': title, 'author': author, } return flask.jsonify(data) Explanation: Item : Pydantic model that represents the structure of the request body. The model has two fields: title and author . create_item : Route that accepts a POST request with a JSON body that must match the Item model. update_item : Route that accepts a URL parameter item_id that must be an integer. The route also accepts two optional JSON body parameters: title and author . The parameters are validated using the library field JsonBody . Create a new Item Invalid request Body: POST http://127.0.0.1:5000/items/ { \"title\": \"Hello, World!\" } Http Response: { \"errors\": [ { \"input\": { \"title\": \"Hello, World!\" }, \"loc\": [ \"body\", \"author\" ], \"msg\": \"Field required\", \"type\": \"missing\", \"url\": \"https://errors.pydantic.dev/2.9/v/missing\" } ] } Update an Item Invalid request Body: PUT http://127.0.0.1:5000/items/123 { \"title\": 111 } Http Response: { \"errors\": [ { \"input\": 111, \"loc\": [ \"body\", \"title\" ], \"msg\": \"Input should be a valid string\", \"type\": \"string_type\", \"url\": \"https://errors.pydantic.dev/2.9/v/string_type\" } ] }","title":"Request Body"},{"location":"body/#using-multiple-pydantic-models-jsonbody-field-with-embed","text":"import typing as t import flask import pydantic import flask_typed_routes as flask_tpr app = flask.Flask(__name__) flask_tpr.FlaskTypeRoutes(app) class Item(pydantic.BaseModel): title: str author: str class User(pydantic.BaseModel): email: str age: int @app.post('/users/<user_id>/items/') def create_item_by_user( user_id: int, item: t.Annotated[Item, flask_tpr.JsonBody(embed=True)], user: t.Annotated[User, flask_tpr.JsonBody(embed=True)], ): # Use `JsonBody` with `embed=True` to validate nested specific fields in the request body data = { 'user_id': user_id, 'item': item.model_dump(), 'user': user.model_dump(), } return flask.jsonify(data) Request Body POST http://127.0.0.1:5000/users/123/items/ { \"item\": { \"title\": \"Hello, World!\", \"author\": \"John Doe\" }, \"user\": { \"email\": \"myemail@abc.com\", \"age\": 25 } } Http Response { \"item\": { \"author\": \"John Doe\", \"title\": \"Hello, World!\" }, \"user\": { \"age\": 25, \"email\": \"myemail@abc.com\" }, \"user_id\": 123 }","title":"Using multiple Pydantic Models, JsonBody Field with embed"},{"location":"cookie/","text":"Cookie Parameters You can define cookie parameters in the same way as query parameters, with support for multiple values. import typing as t import flask import flask_typed_routes as flask_tpr app = flask.Flask(__name__) flask_tpr.FlaskTypeRoutes(app) @app.route('/posts/') def get_posts(session_id: t.Annotated[str, flask_tpr.Cookie(alias=\"session-id\")] = None): data = { 'session_id': session_id, } return flask.jsonify(data)","title":"Cookie parameters"},{"location":"cookie/#cookie-parameters","text":"You can define cookie parameters in the same way as query parameters, with support for multiple values. import typing as t import flask import flask_typed_routes as flask_tpr app = flask.Flask(__name__) flask_tpr.FlaskTypeRoutes(app) @app.route('/posts/') def get_posts(session_id: t.Annotated[str, flask_tpr.Cookie(alias=\"session-id\")] = None): data = { 'session_id': session_id, } return flask.jsonify(data)","title":"Cookie Parameters"},{"location":"errors/","text":"Handling Errors If you need to change default output for validation errors, you can pass a custom error handler to FlaskTypeRoutes constructor. import flask import flask_typed_routes as flask_tpr app = flask.Flask(__name__) def custom_error_handler(error): return flask.jsonify({\"detail\": error.errors}), 400 flask_tpr.FlaskTypeRoutes(app, validation_error_handler=custom_error_handler)","title":"Handling errors"},{"location":"errors/#handling-errors","text":"If you need to change default output for validation errors, you can pass a custom error handler to FlaskTypeRoutes constructor. import flask import flask_typed_routes as flask_tpr app = flask.Flask(__name__) def custom_error_handler(error): return flask.jsonify({\"detail\": error.errors}), 400 flask_tpr.FlaskTypeRoutes(app, validation_error_handler=custom_error_handler)","title":"Handling Errors"},{"location":"header/","text":"Header parameters You can define header parameters in the same way as query/cookie parameters, with support for multiple values. Documentation Under Development !!!","title":"Header parameters"},{"location":"header/#header-parameters","text":"You can define header parameters in the same way as query/cookie parameters, with support for multiple values. Documentation Under Development !!!","title":"Header parameters"},{"location":"path/","text":"Path Parameters This section demonstrates how to use the library to validate and enforce types for path parameters in your Flask application. import typing as t import flask import flask_typed_routes as flask_tpr app = flask.Flask(__name__) flask_tpr.FlaskTypeRoutes(app) @app.route('/posts/<user_id>/<country_iso>') def read_posts(user_id: int, country_iso: t.Annotated[str, flask_tpr.Path(max_length=2)]): data = { 'user_id': user_id, 'country_iso': country_iso, } return flask.jsonify(data) Validations: user_id: Must be an integer. country_iso: Must be a string with a maximum length of 2 characters. This parameter is validated using the libray field Path . Valid Request: http://127.0.0.1:5000/posts/12/ES { \"country_iso\": \"ES\", \"user_id\": 12 } Invalid Requests: Case1 If \"user_id\" is not an integer: http://127.0.0.1:5000/posts/abc/ES { \"errors\": [ { \"input\": \"abc\", \"loc\": [ \"path\", \"user_id\" ], \"msg\": \"Input should be a valid integer, unable to parse string as an integer\", \"type\": \"int_parsing\", \"url\": \"https://errors.pydantic.dev/2.9/v/int_parsing\" } ] } Case2 If \"country_iso\" is not a string with a maximum length of 2 characters: http://127.0.0.1:5000/posts/12/ESP { \"errors\": [ { \"ctx\": { \"max_length\": 2 }, \"input\": \"ESP\", \"loc\": [ \"path\", \"country_iso\" ], \"msg\": \"String should have at most 2 characters\", \"type\": \"string_too_long\", \"url\": \"https://errors.pydantic.dev/2.9/v/string_too_long\" } ] } Custom Path Validations Note The Path field is an extension of Pydantic's field, offering powerful validation capabilities. This flexibility allows you to tailor path parameter validation to your application's specific needs.","title":"Path parameters"},{"location":"path/#path-parameters","text":"This section demonstrates how to use the library to validate and enforce types for path parameters in your Flask application. import typing as t import flask import flask_typed_routes as flask_tpr app = flask.Flask(__name__) flask_tpr.FlaskTypeRoutes(app) @app.route('/posts/<user_id>/<country_iso>') def read_posts(user_id: int, country_iso: t.Annotated[str, flask_tpr.Path(max_length=2)]): data = { 'user_id': user_id, 'country_iso': country_iso, } return flask.jsonify(data) Validations: user_id: Must be an integer. country_iso: Must be a string with a maximum length of 2 characters. This parameter is validated using the libray field Path . Valid Request: http://127.0.0.1:5000/posts/12/ES { \"country_iso\": \"ES\", \"user_id\": 12 } Invalid Requests: Case1 If \"user_id\" is not an integer: http://127.0.0.1:5000/posts/abc/ES { \"errors\": [ { \"input\": \"abc\", \"loc\": [ \"path\", \"user_id\" ], \"msg\": \"Input should be a valid integer, unable to parse string as an integer\", \"type\": \"int_parsing\", \"url\": \"https://errors.pydantic.dev/2.9/v/int_parsing\" } ] } Case2 If \"country_iso\" is not a string with a maximum length of 2 characters: http://127.0.0.1:5000/posts/12/ESP { \"errors\": [ { \"ctx\": { \"max_length\": 2 }, \"input\": \"ESP\", \"loc\": [ \"path\", \"country_iso\" ], \"msg\": \"String should have at most 2 characters\", \"type\": \"string_too_long\", \"url\": \"https://errors.pydantic.dev/2.9/v/string_too_long\" } ] } Custom Path Validations Note The Path field is an extension of Pydantic's field, offering powerful validation capabilities. This flexibility allows you to tailor path parameter validation to your application's specific needs.","title":"Path Parameters"},{"location":"query/","text":"Query parameters Parameters not included in the \"path\" are automatically treated as \"query\" parameters. import typing as t import flask import flask_typed_routes as flask_tpr app = flask.Flask(__name__) flask_tpr.FlaskTypeRoutes(app) @app.route('/posts/') def read_posts(needy: str, skip: int = 0, limit: t.Annotated[int, flask_tpr.Query(alias=\"max\", le=100)] = 100): data = { 'needy': needy, 'skip': skip, 'limit': limit, } return flask.jsonify(data) Explanation: needy : Query parameter that must be included in the request and must be a string. skip : Query parameter that is optional and must be an integer. If not included, it defaults to 0. limit : Query parameter that is optional and must be a string. If not included, it defaults to 100. The parameter is validated using the library field Query with a maximum value of 100. The parameter is also aliased as max . Note The alias is used to demonstrate how the library can support Pydantic's Field class. Valid Request: http://127.0.0.1:5000/posts/?needy=passed&max=20 { \"limit\": 20, \"needy\": \"passed\", \"skip\": 0 } Invalid Requests: Case1 If \"needy\" is not included in the request: http://127.0.0.1:5000/posts/ { \"errors\": [ { \"input\": {}, \"loc\": [ \"query\", \"needy\" ], \"msg\": \"Field required\", \"type\": \"missing\", \"url\": \"https://errors.pydantic.dev/2.9/v/missing\" } ] } Case2 If \"limit\" (alias: \"max\") is greater than 100: http://127.0.0.1:5000/posts/?needy=passed&max=1000 { \"errors\": [ { \"ctx\": { \"le\": 100 }, \"input\": \"1000\", \"loc\": [ \"query\", \"max\" ], \"msg\": \"Input should be less than or equal to 100\", \"type\": \"less_than_equal\", \"url\": \"https://errors.pydantic.dev/2.9/v/less_than_equal\" } ] } Query parameters using Pydantic models If you have a group of query parameters that are related, you can create a Pydantic model to declare them. This would allow you to re-use the model in multiple places and also to declare validations and metadata for all the parameters at once. Note Query field is only used to declare the query parameters in the function signature, in Pydantic models, you can use the Pydantic's Field class to declare constraints and metadata. import typing as t import flask import pydantic import flask_typed_routes as flask_tpr app = flask.Flask(__name__) flask_tpr.FlaskTypeRoutes(app) class QueryParams(pydantic.BaseModel): status: bool skip: int = 0 limit: int = 10 tracking_number: t.Annotated[int, pydantic.Field(alias=\"tracking\", le=3)] = 1 payment_method: t.Literal[\"cash\", \"credit\"] = \"credit\" @app.get('/orders/<user_id>/') def get_orders( user_id: int, params: t.Annotated[QueryParams, flask_tpr.Query()] ): data = {'user_id': user_id, \"params\": params.model_dump()} return flask.jsonify(data) Go to http://127.0.0.1:5000/orders/233/?status=true { \"params\": { \"limit\": 10, \"payment_method\": \"credit\", \"skip\": 0, \"status\": true, \"tracking_number\": 1 }, \"user_id\": 233 } Query parameters with multiple values Tip If you want to allow a query parameter to have multiple values, you can use the multi=True argument in the Annotated import typing as t import flask import flask_typed_routes as flask_tpr app = flask.Flask(__name__) flask_tpr.FlaskTypeRoutes(app) @app.get('/users/<user_id>/') def get_users( user_id: int, tags: t.Annotated[list[str], flask_tpr.Query(alias=\"tag\", multi=True)] = (), ): data = {'user_id': user_id, \"tags\": tags} return flask.jsonify(data) Go to http://127.0.0.1:5000/users/123/?tag=hello&tag=world { \"tags\": [ \"hello\", \"world\" ], \"user_id\": 123 }","title":"Query parameters"},{"location":"query/#query-parameters","text":"Parameters not included in the \"path\" are automatically treated as \"query\" parameters. import typing as t import flask import flask_typed_routes as flask_tpr app = flask.Flask(__name__) flask_tpr.FlaskTypeRoutes(app) @app.route('/posts/') def read_posts(needy: str, skip: int = 0, limit: t.Annotated[int, flask_tpr.Query(alias=\"max\", le=100)] = 100): data = { 'needy': needy, 'skip': skip, 'limit': limit, } return flask.jsonify(data) Explanation: needy : Query parameter that must be included in the request and must be a string. skip : Query parameter that is optional and must be an integer. If not included, it defaults to 0. limit : Query parameter that is optional and must be a string. If not included, it defaults to 100. The parameter is validated using the library field Query with a maximum value of 100. The parameter is also aliased as max . Note The alias is used to demonstrate how the library can support Pydantic's Field class. Valid Request: http://127.0.0.1:5000/posts/?needy=passed&max=20 { \"limit\": 20, \"needy\": \"passed\", \"skip\": 0 } Invalid Requests: Case1 If \"needy\" is not included in the request: http://127.0.0.1:5000/posts/ { \"errors\": [ { \"input\": {}, \"loc\": [ \"query\", \"needy\" ], \"msg\": \"Field required\", \"type\": \"missing\", \"url\": \"https://errors.pydantic.dev/2.9/v/missing\" } ] } Case2 If \"limit\" (alias: \"max\") is greater than 100: http://127.0.0.1:5000/posts/?needy=passed&max=1000 { \"errors\": [ { \"ctx\": { \"le\": 100 }, \"input\": \"1000\", \"loc\": [ \"query\", \"max\" ], \"msg\": \"Input should be less than or equal to 100\", \"type\": \"less_than_equal\", \"url\": \"https://errors.pydantic.dev/2.9/v/less_than_equal\" } ] }","title":"Query parameters"},{"location":"query/#query-parameters-using-pydantic-models","text":"If you have a group of query parameters that are related, you can create a Pydantic model to declare them. This would allow you to re-use the model in multiple places and also to declare validations and metadata for all the parameters at once. Note Query field is only used to declare the query parameters in the function signature, in Pydantic models, you can use the Pydantic's Field class to declare constraints and metadata. import typing as t import flask import pydantic import flask_typed_routes as flask_tpr app = flask.Flask(__name__) flask_tpr.FlaskTypeRoutes(app) class QueryParams(pydantic.BaseModel): status: bool skip: int = 0 limit: int = 10 tracking_number: t.Annotated[int, pydantic.Field(alias=\"tracking\", le=3)] = 1 payment_method: t.Literal[\"cash\", \"credit\"] = \"credit\" @app.get('/orders/<user_id>/') def get_orders( user_id: int, params: t.Annotated[QueryParams, flask_tpr.Query()] ): data = {'user_id': user_id, \"params\": params.model_dump()} return flask.jsonify(data) Go to http://127.0.0.1:5000/orders/233/?status=true { \"params\": { \"limit\": 10, \"payment_method\": \"credit\", \"skip\": 0, \"status\": true, \"tracking_number\": 1 }, \"user_id\": 233 }","title":"Query parameters using Pydantic models"},{"location":"query/#query-parameters-with-multiple-values","text":"Tip If you want to allow a query parameter to have multiple values, you can use the multi=True argument in the Annotated import typing as t import flask import flask_typed_routes as flask_tpr app = flask.Flask(__name__) flask_tpr.FlaskTypeRoutes(app) @app.get('/users/<user_id>/') def get_users( user_id: int, tags: t.Annotated[list[str], flask_tpr.Query(alias=\"tag\", multi=True)] = (), ): data = {'user_id': user_id, \"tags\": tags} return flask.jsonify(data) Go to http://127.0.0.1:5000/users/123/?tag=hello&tag=world { \"tags\": [ \"hello\", \"world\" ], \"user_id\": 123 }","title":"Query parameters with multiple values"}]}