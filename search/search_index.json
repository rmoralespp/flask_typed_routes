{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"About flask_typed_routes is a Flask extension designed to effortlessly validate requests with Pydantic based on standard Python type hints. Features \ud83c\udfaf Type Safety: Automatically validates requests using Python type hints. \ud83d\udd0c Easy Integration: Simple extension for validating Flask routes. \u26a0\ufe0f Error Handling: Clear and automatic responses for validation failures. \u2728 Autocomplete: Editor integration with comprehensive suggestions. \u2699\ufe0f Validation Modes: Supports automatic validation for all routes and manual validation for specific routes using decorators. \ud83d\udcd6 OpenAPI Support: Automatically generates a comprehensive OpenAPI schema, ensuring clear documentation and seamless integration with API tools. Requirements Python 3.10+ Pydantic 2.0+ Flask Installation To install flask_typed_routes using pip , run the following command: pip install flask_typed_routes Getting Started This tool offers comprehensive validation for various types of request parameters, including Path, Query, Body, Header, and Cookie parameters. Example of a simple Flask application using flask_typed_routes : Create a file items.py with: import typing as t import annotated_types as at import flask import flask_typed_routes as ftr import pydantic app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) Skip = pydantic.NonNegativeInt # custom Pydantic type Limit = t.Annotated[int, at.Ge(1), at.Le(100)] # custom Annotated type @app.get('/items/<user>/') def get_items(user: str, skip: Skip = 0, limit: Limit = 10): # Parameters not included in the \"path\" are automatically treated as \"query\" parameters. data = { 'user': user, 'skip': skip, 'limit': limit, } return flask.jsonify(data) Run the server with: flask --app items run --debug Open your browser and go to http://127.0.0.1:5000/items/myuser/?skip=20 You will see the JSON response as: { \"limit\": 10, \"skip\": 20, \"user\": \"myuser\" } Validation: Open your browser and go to http://127.0.0.1:5000/items/myuser/?skip=abc You will see the JSON response with the error details because the skip parameter is not an integer: { \"errors\": [ { \"input\": \"abc\", \"loc\": [ \"query\", \"skip\" ], \"msg\": \"Input should be a valid integer, unable to parse string as an integer\", \"type\": \"int_parsing\", \"url\": \"https://errors.pydantic.dev/2.9/v/int_parsing\" } ] } Example with Pydantic Models You can also use Pydantic models to validate request data in Flask routes. Now let's update the items.py file with: import flask import flask_typed_routes as ftr import pydantic app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) class Item(pydantic.BaseModel): name: str description: str = None price: float @app.post('/items/') def create_item(item: Item): return flask.jsonify(item.model_dump()) @app.put('/items/<item_id>/') def update_item(item_id: int, item: Item): return flask.jsonify({'item_id': item_id, **item.model_dump()}) Using Flask Blueprints You can also use flask_typed_routes with Flask Blueprints. Now let's update the items.py file with: import flask import flask_typed_routes as ftr app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) blp = flask.Blueprint('items', __name__, url_prefix='/v2') @blp.get('/items/') def get_items_v2(skip: int = 0, limit: int = 10, country: str = 'US'): data = {'skip': skip, 'limit': limit, 'country': country} return flask.jsonify(data) app.register_blueprint(blp) Using Flask Class-Based Views You can also use flask_typed_routes with Flask Class-Based Views. Now let's update the items.py file with: import flask import flask.views import flask_typed_routes as ftr app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) class UserProducts(flask.views.View): def dispatch_request(self, user: str, skip: int = 0, limit: int = 10): data = {'user': user, 'skip': skip, 'limit': limit} return flask.jsonify(data) class UserOrders(flask.views.MethodView): def get(self, user: str, skip: int = 0, limit: int = 10): data = {'user': user, 'skip': skip, 'limit': limit} return flask.jsonify(data) app.add_url_rule('/products/<user>/all/', view_func=UserProducts.as_view('user_products')) app.add_url_rule('/orders/<user>/all/', view_func=UserOrders.as_view('user_orders'))","title":"Introduction"},{"location":"#about","text":"flask_typed_routes is a Flask extension designed to effortlessly validate requests with Pydantic based on standard Python type hints.","title":"About"},{"location":"#features","text":"\ud83c\udfaf Type Safety: Automatically validates requests using Python type hints. \ud83d\udd0c Easy Integration: Simple extension for validating Flask routes. \u26a0\ufe0f Error Handling: Clear and automatic responses for validation failures. \u2728 Autocomplete: Editor integration with comprehensive suggestions. \u2699\ufe0f Validation Modes: Supports automatic validation for all routes and manual validation for specific routes using decorators. \ud83d\udcd6 OpenAPI Support: Automatically generates a comprehensive OpenAPI schema, ensuring clear documentation and seamless integration with API tools.","title":"Features"},{"location":"#requirements","text":"Python 3.10+ Pydantic 2.0+ Flask","title":"Requirements"},{"location":"#installation","text":"To install flask_typed_routes using pip , run the following command: pip install flask_typed_routes","title":"Installation"},{"location":"#getting-started","text":"This tool offers comprehensive validation for various types of request parameters, including Path, Query, Body, Header, and Cookie parameters. Example of a simple Flask application using flask_typed_routes : Create a file items.py with: import typing as t import annotated_types as at import flask import flask_typed_routes as ftr import pydantic app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) Skip = pydantic.NonNegativeInt # custom Pydantic type Limit = t.Annotated[int, at.Ge(1), at.Le(100)] # custom Annotated type @app.get('/items/<user>/') def get_items(user: str, skip: Skip = 0, limit: Limit = 10): # Parameters not included in the \"path\" are automatically treated as \"query\" parameters. data = { 'user': user, 'skip': skip, 'limit': limit, } return flask.jsonify(data) Run the server with: flask --app items run --debug Open your browser and go to http://127.0.0.1:5000/items/myuser/?skip=20 You will see the JSON response as: { \"limit\": 10, \"skip\": 20, \"user\": \"myuser\" } Validation: Open your browser and go to http://127.0.0.1:5000/items/myuser/?skip=abc You will see the JSON response with the error details because the skip parameter is not an integer: { \"errors\": [ { \"input\": \"abc\", \"loc\": [ \"query\", \"skip\" ], \"msg\": \"Input should be a valid integer, unable to parse string as an integer\", \"type\": \"int_parsing\", \"url\": \"https://errors.pydantic.dev/2.9/v/int_parsing\" } ] }","title":"Getting Started"},{"location":"#example-with-pydantic-models","text":"You can also use Pydantic models to validate request data in Flask routes. Now let's update the items.py file with: import flask import flask_typed_routes as ftr import pydantic app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) class Item(pydantic.BaseModel): name: str description: str = None price: float @app.post('/items/') def create_item(item: Item): return flask.jsonify(item.model_dump()) @app.put('/items/<item_id>/') def update_item(item_id: int, item: Item): return flask.jsonify({'item_id': item_id, **item.model_dump()})","title":"Example with Pydantic Models"},{"location":"#using-flask-blueprints","text":"You can also use flask_typed_routes with Flask Blueprints. Now let's update the items.py file with: import flask import flask_typed_routes as ftr app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) blp = flask.Blueprint('items', __name__, url_prefix='/v2') @blp.get('/items/') def get_items_v2(skip: int = 0, limit: int = 10, country: str = 'US'): data = {'skip': skip, 'limit': limit, 'country': country} return flask.jsonify(data) app.register_blueprint(blp)","title":"Using Flask Blueprints"},{"location":"#using-flask-class-based-views","text":"You can also use flask_typed_routes with Flask Class-Based Views. Now let's update the items.py file with: import flask import flask.views import flask_typed_routes as ftr app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) class UserProducts(flask.views.View): def dispatch_request(self, user: str, skip: int = 0, limit: int = 10): data = {'user': user, 'skip': skip, 'limit': limit} return flask.jsonify(data) class UserOrders(flask.views.MethodView): def get(self, user: str, skip: int = 0, limit: int = 10): data = {'user': user, 'skip': skip, 'limit': limit} return flask.jsonify(data) app.add_url_rule('/products/<user>/all/', view_func=UserProducts.as_view('user_products')) app.add_url_rule('/orders/<user>/all/', view_func=UserOrders.as_view('user_orders'))","title":"Using Flask Class-Based Views"},{"location":"body/","text":"Request Body To declare a request body, you use Pydantic models with all their power and benefits By default, the library interprets a Pydantic model used as a type annotation in a function signature as a request body model. However, if you only want to validate specific fields in the request body, you can use the Body Field annotation. Note This Body Field is an extension of Pydantic's field Basic Usage of request Body Validation: import typing as t import pydantic import flask import flask_typed_routes as flask_tpr app = flask.Flask(__name__) flask_tpr.FlaskTypedRoutes(app) class Item(pydantic.BaseModel): title: str author: str @app.post('/items/') def create_item(item: Item): # Use Pydantic model to validate the request body return flask.jsonify(item.model_dump()) @app.put('/items/<item_id>/') def update_item( item_id: int, title: t.Annotated[str, flask_tpr.Body()] = None, author: t.Annotated[str, flask_tpr.Body()] = None, ): # Use `Body` to validate specific fields in the request body data = { 'item_id': item_id, 'title': title, 'author': author, } return flask.jsonify(data) Explanation: Item : Pydantic model that represents the structure of the request body. The model has two fields: title and author . create_item : Route that accepts a POST request with a JSON body that must match the Item model. update_item : Route that accepts a URL parameter item_id that must be an integer. The route also accepts two optional JSON body parameters: title and author . The parameters are validated using the library field Body . Create a new Item: Invalid request Body POST http://127.0.0.1:5000/items/ { \"title\": \"Hello, World!\" } Http Response: { \"errors\": [ { \"input\": { \"title\": \"Hello, World!\" }, \"loc\": [ \"body\", \"author\" ], \"msg\": \"Field required\", \"type\": \"missing\", \"url\": \"https://errors.pydantic.dev/2.9/v/missing\" } ] } Update an Item: Invalid request Body PUT http://127.0.0.1:5000/items/123 { \"title\": 111 } Http Response: { \"errors\": [ { \"input\": 111, \"loc\": [ \"body\", \"title\" ], \"msg\": \"Input should be a valid string\", \"type\": \"string_type\", \"url\": \"https://errors.pydantic.dev/2.9/v/string_type\" } ] } Multiple Pydantic Models You can use multiple Pydantic models in a single route and validate specific fields in the request body using the Body field with the embed parameter. import typing as t import pydantic import flask import flask_typed_routes as ftr app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) class Item(pydantic.BaseModel): title: str author: str class User(pydantic.BaseModel): email: str age: int @app.post('/users/<user_id>/items/') def create_item_by_user( user_id: int, item: t.Annotated[Item, ftr.Body(embed=True)], user: t.Annotated[User, ftr.Body(embed=True)], ): # Use `Body` with `embed=True` to validate nested specific fields in the request body data = { 'user_id': user_id, 'item': item.model_dump(), 'user': user.model_dump(), } return flask.jsonify(data) Example request: POST http://127.0.0.1:5000/users/123/items/ { \"item\": { \"title\": \"Hello, World!\", \"author\": \"John Doe\" }, \"user\": { \"email\": \"myemail@abc.com\", \"age\": 25 } }","title":"Request body"},{"location":"body/#request-body","text":"To declare a request body, you use Pydantic models with all their power and benefits By default, the library interprets a Pydantic model used as a type annotation in a function signature as a request body model. However, if you only want to validate specific fields in the request body, you can use the Body Field annotation. Note This Body Field is an extension of Pydantic's field Basic Usage of request Body Validation: import typing as t import pydantic import flask import flask_typed_routes as flask_tpr app = flask.Flask(__name__) flask_tpr.FlaskTypedRoutes(app) class Item(pydantic.BaseModel): title: str author: str @app.post('/items/') def create_item(item: Item): # Use Pydantic model to validate the request body return flask.jsonify(item.model_dump()) @app.put('/items/<item_id>/') def update_item( item_id: int, title: t.Annotated[str, flask_tpr.Body()] = None, author: t.Annotated[str, flask_tpr.Body()] = None, ): # Use `Body` to validate specific fields in the request body data = { 'item_id': item_id, 'title': title, 'author': author, } return flask.jsonify(data) Explanation: Item : Pydantic model that represents the structure of the request body. The model has two fields: title and author . create_item : Route that accepts a POST request with a JSON body that must match the Item model. update_item : Route that accepts a URL parameter item_id that must be an integer. The route also accepts two optional JSON body parameters: title and author . The parameters are validated using the library field Body . Create a new Item: Invalid request Body POST http://127.0.0.1:5000/items/ { \"title\": \"Hello, World!\" } Http Response: { \"errors\": [ { \"input\": { \"title\": \"Hello, World!\" }, \"loc\": [ \"body\", \"author\" ], \"msg\": \"Field required\", \"type\": \"missing\", \"url\": \"https://errors.pydantic.dev/2.9/v/missing\" } ] } Update an Item: Invalid request Body PUT http://127.0.0.1:5000/items/123 { \"title\": 111 } Http Response: { \"errors\": [ { \"input\": 111, \"loc\": [ \"body\", \"title\" ], \"msg\": \"Input should be a valid string\", \"type\": \"string_type\", \"url\": \"https://errors.pydantic.dev/2.9/v/string_type\" } ] }","title":"Request Body"},{"location":"body/#multiple-pydantic-models","text":"You can use multiple Pydantic models in a single route and validate specific fields in the request body using the Body field with the embed parameter. import typing as t import pydantic import flask import flask_typed_routes as ftr app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) class Item(pydantic.BaseModel): title: str author: str class User(pydantic.BaseModel): email: str age: int @app.post('/users/<user_id>/items/') def create_item_by_user( user_id: int, item: t.Annotated[Item, ftr.Body(embed=True)], user: t.Annotated[User, ftr.Body(embed=True)], ): # Use `Body` with `embed=True` to validate nested specific fields in the request body data = { 'user_id': user_id, 'item': item.model_dump(), 'user': user.model_dump(), } return flask.jsonify(data) Example request: POST http://127.0.0.1:5000/users/123/items/ { \"item\": { \"title\": \"Hello, World!\", \"author\": \"John Doe\" }, \"user\": { \"email\": \"myemail@abc.com\", \"age\": 25 } }","title":"Multiple Pydantic Models"},{"location":"cookie/","text":"Cookie Parameters You can define cookie parameters in the same way as query parameters , with support for multiple values and validation using Pydantic models. import typing as t import flask import flask_typed_routes as ftr app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) SessionId = t.Annotated[str, ftr.Cookie(alias=\"session-id\")] @app.route('/items/') def get_items(session_id: SessionId = None): data = { 'session_id': session_id, } return flask.jsonify(data)","title":"Cookie parameters"},{"location":"cookie/#cookie-parameters","text":"You can define cookie parameters in the same way as query parameters , with support for multiple values and validation using Pydantic models. import typing as t import flask import flask_typed_routes as ftr app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) SessionId = t.Annotated[str, ftr.Cookie(alias=\"session-id\")] @app.route('/items/') def get_items(session_id: SessionId = None): data = { 'session_id': session_id, } return flask.jsonify(data)","title":"Cookie Parameters"},{"location":"errors/","text":"Handling Errors If you need to change default output for validation errors, you can pass a custom error handler to FlaskTypedRoutes constructor. import flask import flask_typed_routes as flask_tpr app = flask.Flask(__name__) def custom_error_handler(error): return flask.jsonify({\"detail\": error.errors}), 400 flask_tpr.FlaskTypedRoutes(app, validation_error_handler=custom_error_handler)","title":"Handling errors"},{"location":"errors/#handling-errors","text":"If you need to change default output for validation errors, you can pass a custom error handler to FlaskTypedRoutes constructor. import flask import flask_typed_routes as flask_tpr app = flask.Flask(__name__) def custom_error_handler(error): return flask.jsonify({\"detail\": error.errors}), 400 flask_tpr.FlaskTypedRoutes(app, validation_error_handler=custom_error_handler)","title":"Handling Errors"},{"location":"header/","text":"Header parameters You can define header parameters in the same way as query/cookie parameters , with support for multiple values and validation using Pydantic models. import typing as t import flask import flask_typed_routes as ftr app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) @app.route('/items/') def get_items(auth: t.Annotated[str, ftr.Header(alias=\"Authorization\")] = None): data = { 'auth': auth, } return flask.jsonify(data)","title":"Header parameters"},{"location":"header/#header-parameters","text":"You can define header parameters in the same way as query/cookie parameters , with support for multiple values and validation using Pydantic models. import typing as t import flask import flask_typed_routes as ftr app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) @app.route('/items/') def get_items(auth: t.Annotated[str, ftr.Header(alias=\"Authorization\")] = None): data = { 'auth': auth, } return flask.jsonify(data)","title":"Header parameters"},{"location":"mode/","text":"Validation Modes The library provides two modes of operation for request validation: auto and manual . These modes determine how validation is applied to endpoints. auto Mode (Default) In auto mode, the library automatically validates the requests of all endpoints that have type hints in their function signatures. This mode simplifies development by eliminating the need for explicit configuration, ensuring that all typed routes are validated without additional effort. Key Features of auto Mode: Automatically validates all routes with type hints. Minimal configuration required. Suitable for most use cases where automatic validation is preferred. Example: import typing as t import annotated_types as at import flask import flask_typed_routes as ftr api = flask.Flask(__name__) ftr.FlaskTypedRoutes(api) # Default mode is 'auto' @api.get('/products/<int:product_id>/') def get_product(pk: t.Annotated[int, at.Gt(10)]): # The 'product_id' parameter is automatically validated as an integer. return flask.jsonify({\"product_id\": pk}) @api.get('/orders/<int:order_id>/') def get_order(order_id: t.Annotated[int, at.Gt(10)]): # The 'order_id' parameter is also automatically validated. return flask.jsonify({\"order_id\": order_id}) In this example, both get_product and get_order endpoints automatically validate the incoming parameters based on their type hints. manual Mode In manual mode, the user explicitly specifies which routes should be validated by applying the typed_route decorator. This mode provides greater control, allowing developers to selectively enable validation only where needed. Key Features of manual Mode: Validation is applied only to routes with the typed_route decorator. Offers granular control over validation. Useful for advanced use cases where not all routes require validation. How to Enable manual Mode: Set the mode to manual when initializing the library: import typing as t import annotated_types as at import flask import flask_typed_routes as ftr api = flask.Flask(__name__) ftr.FlaskTypedRoutes(api, mode=ftr.Mode.manual) @api.get('/products/<int:pk>/') @ftr.typed_route() # Validation is explicitly enabled for this route. def get_product(pk: t.Annotated[int, at.Gt(10)]): # The 'pk' parameter is validated as an integer. return flask.jsonify({\"pk\": pk}) @api.get('/orders/<int:order_id>/') def get_order(order_id: t.Annotated[int, at.Gt(10)]): # The 'order_id' parameter is NOT validated. return flask.jsonify({\"order_id\": order_id}) In this example: The get_product endpoint validates the pk parameter because the typed_route decorator is applied. The get_order endpoint does not validate the order_id parameter because it lacks the decorator. Summary Mode Validation Scope Use Case auto All endpoints with type hints Default, for seamless validation manual Only endpoints with typed_route decorator Advanced, for selective validation Choose the mode that best suits your project's needs. For most cases, auto mode provides a hassle-free experience, while manual mode allows for precise control over validation behavior.","title":"Validation Modes"},{"location":"mode/#validation-modes","text":"The library provides two modes of operation for request validation: auto and manual . These modes determine how validation is applied to endpoints.","title":"Validation Modes"},{"location":"mode/#auto-mode-default","text":"In auto mode, the library automatically validates the requests of all endpoints that have type hints in their function signatures. This mode simplifies development by eliminating the need for explicit configuration, ensuring that all typed routes are validated without additional effort.","title":"auto Mode (Default)"},{"location":"mode/#key-features-of-auto-mode","text":"Automatically validates all routes with type hints. Minimal configuration required. Suitable for most use cases where automatic validation is preferred.","title":"Key Features of auto Mode:"},{"location":"mode/#example","text":"import typing as t import annotated_types as at import flask import flask_typed_routes as ftr api = flask.Flask(__name__) ftr.FlaskTypedRoutes(api) # Default mode is 'auto' @api.get('/products/<int:product_id>/') def get_product(pk: t.Annotated[int, at.Gt(10)]): # The 'product_id' parameter is automatically validated as an integer. return flask.jsonify({\"product_id\": pk}) @api.get('/orders/<int:order_id>/') def get_order(order_id: t.Annotated[int, at.Gt(10)]): # The 'order_id' parameter is also automatically validated. return flask.jsonify({\"order_id\": order_id}) In this example, both get_product and get_order endpoints automatically validate the incoming parameters based on their type hints.","title":"Example:"},{"location":"mode/#manual-mode","text":"In manual mode, the user explicitly specifies which routes should be validated by applying the typed_route decorator. This mode provides greater control, allowing developers to selectively enable validation only where needed.","title":"manual Mode"},{"location":"mode/#key-features-of-manual-mode","text":"Validation is applied only to routes with the typed_route decorator. Offers granular control over validation. Useful for advanced use cases where not all routes require validation.","title":"Key Features of manual Mode:"},{"location":"mode/#how-to-enable-manual-mode","text":"Set the mode to manual when initializing the library: import typing as t import annotated_types as at import flask import flask_typed_routes as ftr api = flask.Flask(__name__) ftr.FlaskTypedRoutes(api, mode=ftr.Mode.manual) @api.get('/products/<int:pk>/') @ftr.typed_route() # Validation is explicitly enabled for this route. def get_product(pk: t.Annotated[int, at.Gt(10)]): # The 'pk' parameter is validated as an integer. return flask.jsonify({\"pk\": pk}) @api.get('/orders/<int:order_id>/') def get_order(order_id: t.Annotated[int, at.Gt(10)]): # The 'order_id' parameter is NOT validated. return flask.jsonify({\"order_id\": order_id}) In this example: The get_product endpoint validates the pk parameter because the typed_route decorator is applied. The get_order endpoint does not validate the order_id parameter because it lacks the decorator.","title":"How to Enable manual Mode:"},{"location":"mode/#summary","text":"Mode Validation Scope Use Case auto All endpoints with type hints Default, for seamless validation manual Only endpoints with typed_route decorator Advanced, for selective validation Choose the mode that best suits your project's needs. For most cases, auto mode provides a hassle-free experience, while manual mode allows for precise control over validation behavior.","title":"Summary"},{"location":"openapi/","text":"OpenApi This library automatically generates an OpenApi schema based on the type annotations defined in the application's endpoints. This schema can be used both to document the API and to validate incoming requests with any library compatible with OpenApi. In the examples, we will use the swagger-ui-py library to visualize the documentation generated by flask_typed_routes . The schema is fully customizable to meet the specific needs of the application. Additionally, the library provides the typed_route decorator, which allows parameterizing the various fields supported by OpenApi to describe an operation. More details on its usage can be found in the corresponding sections of this documentation. Note Can be accessed through the openapi_schema attribute of the FlaskTypedRoutes instance. Basic Usage Tip Ensure that the swagger-ui-py library is installed to visualize the OpenApi schema. pip install swagger-ui-py # ignore if already installed import typing as t import flask.views import pydantic import swagger_ui import flask_typed_routes as ftr app = flask.Flask(__name__) app_ftr = ftr.FlaskTypedRoutes(app) swagger_ui.api_doc(app, config=app_ftr.openapi_schema, url_prefix='/api/doc', title='API doc') class Item(pydantic.BaseModel): name: str description: str = None price: float tax: float = None class Params(pydantic.BaseModel): skip: int = 0 limit: int = pydantic.Field(le=100, default=10) status: str = pydantic.Field(description='status of the item', deprecated=True, default='active') @app.get('/items/') def get_items(params: t.Annotated[Params, ftr.Query()]): return flask.jsonify(params.model_dump()) @app.post('/items/') def create_item(item: Item): return flask.jsonify(item.model_dump()) @app.get('/items/<item_id>/') def get_item(item_id: int): return flask.jsonify({'item_id': item_id}) @app.put('/items/<item_id>/') def update_item(item_id: int, item: Item): return flask.jsonify({'item_id': item_id, **item.model_dump()}) @app.delete('/items/<item_id>/') def remove_item(item_id: int): return flask.jsonify({'item_id': item_id}) In this example if you run the application and navigate to http://127.0.0.1:5000/api/doc , you will see the documentation generated by the swagger-ui-py library using the OpenApi schema generated by flask_typed_routes . Using typed_route decorator The typed_route decorator allows you to parameterize the various fields supported by OpenApi to describe an operation. import flask.views import swagger_ui import flask_typed_routes as ftr app = flask.Flask(__name__) app_ftr = ftr.FlaskTypedRoutes(app) swagger_ui.api_doc(app, config=app_ftr.openapi_schema, url_prefix='/api/doc', title='API doc') @app.get('/items/<item_id>/') @ftr.typed_route( summary='Get item by ID', tags=['items'], ) def get_item(item_id: int): return flask.jsonify({'item_id': item_id})","title":"OpenAPI"},{"location":"openapi/#openapi","text":"This library automatically generates an OpenApi schema based on the type annotations defined in the application's endpoints. This schema can be used both to document the API and to validate incoming requests with any library compatible with OpenApi. In the examples, we will use the swagger-ui-py library to visualize the documentation generated by flask_typed_routes . The schema is fully customizable to meet the specific needs of the application. Additionally, the library provides the typed_route decorator, which allows parameterizing the various fields supported by OpenApi to describe an operation. More details on its usage can be found in the corresponding sections of this documentation. Note Can be accessed through the openapi_schema attribute of the FlaskTypedRoutes instance.","title":"OpenApi"},{"location":"openapi/#basic-usage","text":"Tip Ensure that the swagger-ui-py library is installed to visualize the OpenApi schema. pip install swagger-ui-py # ignore if already installed import typing as t import flask.views import pydantic import swagger_ui import flask_typed_routes as ftr app = flask.Flask(__name__) app_ftr = ftr.FlaskTypedRoutes(app) swagger_ui.api_doc(app, config=app_ftr.openapi_schema, url_prefix='/api/doc', title='API doc') class Item(pydantic.BaseModel): name: str description: str = None price: float tax: float = None class Params(pydantic.BaseModel): skip: int = 0 limit: int = pydantic.Field(le=100, default=10) status: str = pydantic.Field(description='status of the item', deprecated=True, default='active') @app.get('/items/') def get_items(params: t.Annotated[Params, ftr.Query()]): return flask.jsonify(params.model_dump()) @app.post('/items/') def create_item(item: Item): return flask.jsonify(item.model_dump()) @app.get('/items/<item_id>/') def get_item(item_id: int): return flask.jsonify({'item_id': item_id}) @app.put('/items/<item_id>/') def update_item(item_id: int, item: Item): return flask.jsonify({'item_id': item_id, **item.model_dump()}) @app.delete('/items/<item_id>/') def remove_item(item_id: int): return flask.jsonify({'item_id': item_id}) In this example if you run the application and navigate to http://127.0.0.1:5000/api/doc , you will see the documentation generated by the swagger-ui-py library using the OpenApi schema generated by flask_typed_routes .","title":"Basic Usage"},{"location":"openapi/#using-typed_route-decorator","text":"The typed_route decorator allows you to parameterize the various fields supported by OpenApi to describe an operation. import flask.views import swagger_ui import flask_typed_routes as ftr app = flask.Flask(__name__) app_ftr = ftr.FlaskTypedRoutes(app) swagger_ui.api_doc(app, config=app_ftr.openapi_schema, url_prefix='/api/doc', title='API doc') @app.get('/items/<item_id>/') @ftr.typed_route( summary='Get item by ID', tags=['items'], ) def get_item(item_id: int): return flask.jsonify({'item_id': item_id})","title":"Using typed_route decorator"},{"location":"path/","text":"Path Parameters You can validate Path parameters in your route by adding standard type hints to the function signature. Warning If no type hint is provided, the Path parameters are not validated. import typing as t import flask import flask_typed_routes as ftr app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) @app.route('/items/<category_id>/<lang>/') def read_items(category_id: int, lang: t.Literal['es', 'en']): data = {'category_id': category_id, 'lang': lang} return flask.jsonify(data) Conversion: The library automatically converts path parameters to their specified types: category_id is converted to an integer, so your function receives it as an integer. lang is treated as a string, so your function receives it as a string. Validation: category_id Must be an integer. lang Must be either 'es' or 'en'. Example request: GET http://127.0.0.1:5000/items/12/es { \"category_id\": 12, \"lang\": \"es\" } Bad request example: If category_id is not an integer GET http://127.0.0.1:5000/items/abc/es { \"errors\": [ { \"input\": \"abc\", \"loc\": [ \"path\", \"category_id\" ], \"msg\": \"Input should be a valid integer, unable to parse string as an integer\", \"type\": \"int_parsing\", \"url\": \"https://errors.pydantic.dev/2.9/v/int_parsing\" } ] } Additional validations You can leverage Pydantic's custom types or define your own custom data types to apply additional validation to your path parameters. import typing as t import annotated_types as at import flask import flask_typed_routes as ftr app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) @app.route('/items/<category_id>/') def read_items(category_id: t.Annotated[int, at.Ge(1), at.Le(100)]): data = {'category_id': category_id} return flask.jsonify(data) Alternatively, you can use the Path field. This field is an extension of Pydantic's field , offering powerful validation capabilities. This flexibility allows you to tailor path parameter validation to your application's specific needs. import typing as t import flask import flask_typed_routes as ftr app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) @app.route('/items/<category_id>/') def read_items(category_id: t.Annotated[int, ftr.Path(ge=1, le=100)]): data = {'category_id': category_id} return flask.jsonify(data) Validation: category_id must be an integer between 1 and 100. Aliasing Warning Aliases defined in Path type hints will be ignored to maintain consistency with the names specified in the Flask route.","title":"Path parameters"},{"location":"path/#path-parameters","text":"You can validate Path parameters in your route by adding standard type hints to the function signature. Warning If no type hint is provided, the Path parameters are not validated. import typing as t import flask import flask_typed_routes as ftr app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) @app.route('/items/<category_id>/<lang>/') def read_items(category_id: int, lang: t.Literal['es', 'en']): data = {'category_id': category_id, 'lang': lang} return flask.jsonify(data) Conversion: The library automatically converts path parameters to their specified types: category_id is converted to an integer, so your function receives it as an integer. lang is treated as a string, so your function receives it as a string. Validation: category_id Must be an integer. lang Must be either 'es' or 'en'. Example request: GET http://127.0.0.1:5000/items/12/es { \"category_id\": 12, \"lang\": \"es\" } Bad request example: If category_id is not an integer GET http://127.0.0.1:5000/items/abc/es { \"errors\": [ { \"input\": \"abc\", \"loc\": [ \"path\", \"category_id\" ], \"msg\": \"Input should be a valid integer, unable to parse string as an integer\", \"type\": \"int_parsing\", \"url\": \"https://errors.pydantic.dev/2.9/v/int_parsing\" } ] }","title":"Path Parameters"},{"location":"path/#additional-validations","text":"You can leverage Pydantic's custom types or define your own custom data types to apply additional validation to your path parameters. import typing as t import annotated_types as at import flask import flask_typed_routes as ftr app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) @app.route('/items/<category_id>/') def read_items(category_id: t.Annotated[int, at.Ge(1), at.Le(100)]): data = {'category_id': category_id} return flask.jsonify(data) Alternatively, you can use the Path field. This field is an extension of Pydantic's field , offering powerful validation capabilities. This flexibility allows you to tailor path parameter validation to your application's specific needs. import typing as t import flask import flask_typed_routes as ftr app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) @app.route('/items/<category_id>/') def read_items(category_id: t.Annotated[int, ftr.Path(ge=1, le=100)]): data = {'category_id': category_id} return flask.jsonify(data) Validation: category_id must be an integer between 1 and 100.","title":"Additional validations"},{"location":"path/#aliasing","text":"Warning Aliases defined in Path type hints will be ignored to maintain consistency with the names specified in the Flask route.","title":"Aliasing"},{"location":"query/","text":"Query parameters Parameters not included in the Path are automatically treated as Query parameters. Required: Declared as function arguments without default values. Optional: Declared with default values. import flask import flask_typed_routes as ftr app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) @app.route('/items/') def get_items(needy: str, skip: int = 0, limit: int = 100): data = { 'needy': needy, 'skip': skip, 'limit': limit, } return flask.jsonify(data) Validation: needy : Required and must be a string. skip : Optional and must be an integer. If not included, it defaults to 0. limit : Optional and must be an integer. If not included, it defaults to 100. Example request: GET http://127.0.0.1:5000/items/?needy=passed&skip=20 { \"limit\": 100, \"needy\": \"passed\", \"skip\": 20 } Bad request example: If needy is not included in the request http://127.0.0.1:5000/items/ { \"errors\": [ { \"input\": {}, \"loc\": [ \"query\", \"needy\" ], \"msg\": \"Field required\", \"type\": \"missing\", \"url\": \"https://errors.pydantic.dev/2.9/v/missing\" } ] } Additional validations You can leverage Pydantic's custom types or define your own custom data types to apply additional validation to your query parameters. import typing as t import annotated_types as at import flask import pydantic import flask_typed_routes as ftr app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) # Custom Types for additional validation combining Pydantic and Annotated Needy = t.Annotated[str, at.MinLen(3), at.MaxLen(10)] Limit = t.Annotated[int, at.Ge(1), at.Le(100), pydantic.Field(alias=\"size\")] @app.route('/items/') def get_items(needy: Needy, skip: int = 0, limit: Limit = 100): data = { 'needy': needy, 'skip': skip, 'limit': limit, } return flask.jsonify(data) Alternatively, you can use the Query field. This field is an extension of Pydantic's field , offering powerful validation capabilities. This flexibility allows you to tailor query parameter validation to your application's specific needs. Tip The Query field is supported aliasing. You can use the alias argument to define the query parameter name in the request. import typing as t import flask import flask_typed_routes as ftr app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) Needy = t.Annotated[str, ftr.Query(min_length=3, max_length=10)] Limit = t.Annotated[int, ftr.Query(ge=1, le=100, alias=\"size\")] @app.route('/items/') def get_items(needy: Needy, skip: int = 0, limit: Limit = 100): data = { 'needy': needy, 'skip': skip, 'limit': limit, } return flask.jsonify(data) Validation: needy : Required and must be a string between 3 and 10 characters. skip : Optional and must be an integer. limit : Optional and must be an integer between 1 and 100, and must be named size in the request. Example request: GET http://127.0.0.1:5000/items/?needy=passed&size=20 { \"limit\": 20, \"needy\": \"passed\", \"skip\": 0 } Pydantic models If you have a group of query parameters that are related, you can create a Pydantic model to declare them. This would allow you to re-use the model in multiple places and also to declare validations and metadata for all the parameters at once. import typing as t import pydantic import flask import flask_typed_routes as ftr app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) class QueryParams(pydantic.BaseModel): status: bool skip: int = 0 limit: int = 10 tracking_number: t.Annotated[int, pydantic.Field(alias=\"tracking\", le=3)] = 1 payment_method: t.Literal[\"cash\", \"credit\"] = \"credit\" @app.get('/orders/<user_id>/') def get_orders( user_id: int, params: t.Annotated[QueryParams, ftr.Query()] ): data = {'user_id': user_id, \"params\": params.model_dump()} return flask.jsonify(data) Warning The Query field can only be directly specified in the function signature . When using Pydantic models, you must use Pydantic's fields . Example request: GET ttp://127.0.0.1:5000/orders/233/?status=true { \"params\": { \"limit\": 10, \"payment_method\": \"credit\", \"skip\": 0, \"status\": true, \"tracking_number\": 1 }, \"user_id\": 233 } Multiple values If you want to allow a query parameter to have multiple values, you can use the multi=True argument in the Query field. import typing as t import flask import flask_typed_routes as ftr app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) Tags = t.Annotated[list[str], ftr.Query(alias=\"tag\", multi=True)] @app.get('/users/<user_id>/') def get_users(user_id: int, tags: Tags = ()): data = {'user_id': user_id, \"tags\": tags} return flask.jsonify(data) Example request: GET http://127.0.0.1:5000/users/123/?tag=hello&tag=world { \"tags\": [ \"hello\", \"world\" ], \"user_id\": 123 }","title":"Query parameters"},{"location":"query/#query-parameters","text":"Parameters not included in the Path are automatically treated as Query parameters. Required: Declared as function arguments without default values. Optional: Declared with default values. import flask import flask_typed_routes as ftr app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) @app.route('/items/') def get_items(needy: str, skip: int = 0, limit: int = 100): data = { 'needy': needy, 'skip': skip, 'limit': limit, } return flask.jsonify(data) Validation: needy : Required and must be a string. skip : Optional and must be an integer. If not included, it defaults to 0. limit : Optional and must be an integer. If not included, it defaults to 100. Example request: GET http://127.0.0.1:5000/items/?needy=passed&skip=20 { \"limit\": 100, \"needy\": \"passed\", \"skip\": 20 } Bad request example: If needy is not included in the request http://127.0.0.1:5000/items/ { \"errors\": [ { \"input\": {}, \"loc\": [ \"query\", \"needy\" ], \"msg\": \"Field required\", \"type\": \"missing\", \"url\": \"https://errors.pydantic.dev/2.9/v/missing\" } ] }","title":"Query parameters"},{"location":"query/#additional-validations","text":"You can leverage Pydantic's custom types or define your own custom data types to apply additional validation to your query parameters. import typing as t import annotated_types as at import flask import pydantic import flask_typed_routes as ftr app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) # Custom Types for additional validation combining Pydantic and Annotated Needy = t.Annotated[str, at.MinLen(3), at.MaxLen(10)] Limit = t.Annotated[int, at.Ge(1), at.Le(100), pydantic.Field(alias=\"size\")] @app.route('/items/') def get_items(needy: Needy, skip: int = 0, limit: Limit = 100): data = { 'needy': needy, 'skip': skip, 'limit': limit, } return flask.jsonify(data) Alternatively, you can use the Query field. This field is an extension of Pydantic's field , offering powerful validation capabilities. This flexibility allows you to tailor query parameter validation to your application's specific needs. Tip The Query field is supported aliasing. You can use the alias argument to define the query parameter name in the request. import typing as t import flask import flask_typed_routes as ftr app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) Needy = t.Annotated[str, ftr.Query(min_length=3, max_length=10)] Limit = t.Annotated[int, ftr.Query(ge=1, le=100, alias=\"size\")] @app.route('/items/') def get_items(needy: Needy, skip: int = 0, limit: Limit = 100): data = { 'needy': needy, 'skip': skip, 'limit': limit, } return flask.jsonify(data) Validation: needy : Required and must be a string between 3 and 10 characters. skip : Optional and must be an integer. limit : Optional and must be an integer between 1 and 100, and must be named size in the request. Example request: GET http://127.0.0.1:5000/items/?needy=passed&size=20 { \"limit\": 20, \"needy\": \"passed\", \"skip\": 0 }","title":"Additional validations"},{"location":"query/#pydantic-models","text":"If you have a group of query parameters that are related, you can create a Pydantic model to declare them. This would allow you to re-use the model in multiple places and also to declare validations and metadata for all the parameters at once. import typing as t import pydantic import flask import flask_typed_routes as ftr app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) class QueryParams(pydantic.BaseModel): status: bool skip: int = 0 limit: int = 10 tracking_number: t.Annotated[int, pydantic.Field(alias=\"tracking\", le=3)] = 1 payment_method: t.Literal[\"cash\", \"credit\"] = \"credit\" @app.get('/orders/<user_id>/') def get_orders( user_id: int, params: t.Annotated[QueryParams, ftr.Query()] ): data = {'user_id': user_id, \"params\": params.model_dump()} return flask.jsonify(data) Warning The Query field can only be directly specified in the function signature . When using Pydantic models, you must use Pydantic's fields . Example request: GET ttp://127.0.0.1:5000/orders/233/?status=true { \"params\": { \"limit\": 10, \"payment_method\": \"credit\", \"skip\": 0, \"status\": true, \"tracking_number\": 1 }, \"user_id\": 233 }","title":"Pydantic models"},{"location":"query/#multiple-values","text":"If you want to allow a query parameter to have multiple values, you can use the multi=True argument in the Query field. import typing as t import flask import flask_typed_routes as ftr app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) Tags = t.Annotated[list[str], ftr.Query(alias=\"tag\", multi=True)] @app.get('/users/<user_id>/') def get_users(user_id: int, tags: Tags = ()): data = {'user_id': user_id, \"tags\": tags} return flask.jsonify(data) Example request: GET http://127.0.0.1:5000/users/123/?tag=hello&tag=world { \"tags\": [ \"hello\", \"world\" ], \"user_id\": 123 }","title":"Multiple values"}]}