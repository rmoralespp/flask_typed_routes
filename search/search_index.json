{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"About flask_typed_routes is a Flask extension designed to validate requests effortlessly with Pydantic . Features \ud83c\udfaf Type Safety: Automatically validates requests based on standard Python type hints. \ud83d\udd0c Easy Integration: Simple Flask extension for applying validation to Flask routes. \u26a0\ufe0f Error Handling: Automatically returns meaningful error responses for validation failures. \u2728 Autocomplete : Excellent editor integration, offering comprehensive completion across all contexts. Requirements Python 3.10+ Pydantic 2.0+ Flask Installation To install flask_typed_routes using pip , run the following command: pip install flask_typed_routes Getting Started This tool offers comprehensive validation for various types of request parameters, including Path, Query, Body, Header, and Cookie parameters. Example of a simple Flask application using flask_typed_routes : Create a file items.py with: import typing as t import annotated_types as at import flask import flask_typed_routes as ftr import pydantic app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) Skip = pydantic.NonNegativeInt # custom Pydantic type Limit = t.Annotated[int, at.Ge(1), at.Le(100)] # custom Annotated type @app.get('/items/<user>/') def get_items(user: str, skip: Skip = 0, limit: Limit = 10): # Parameters not included in the \"path\" are automatically treated as \"query\" parameters. data = { 'user': user, 'skip': skip, 'limit': limit, } return flask.jsonify(data) Run the server with: flask --app items run --debug Open your browser and go to http://127.0.0.1:5000/items/myuser/?skip=20 You will see the JSON response as: { \"limit\": 10, \"skip\": 20, \"user\": \"myuser\" } Validation: Open your browser and go to http://127.0.0.1:5000/items/myuser/?skip=abc You will see the JSON response with the error details because the skip parameter is not an integer: { \"errors\": [ { \"input\": \"abc\", \"loc\": [ \"query\", \"skip\" ], \"msg\": \"Input should be a valid integer, unable to parse string as an integer\", \"type\": \"int_parsing\", \"url\": \"https://errors.pydantic.dev/2.9/v/int_parsing\" } ] } Example with Pydantic Models You can also use Pydantic models to validate request data in Flask routes. Now let's update the items.py file with: import flask import flask_typed_routes as ftr import pydantic app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) class Item(pydantic.BaseModel): name: str description: str = None price: float @app.post('/items/') def create_item(item: Item): return flask.jsonify(item.model_dump()) @app.put('/items/<item_id>/') def update_item(item_id: int, item: Item): return flask.jsonify({'item_id': item_id, **item.model_dump()}) Using Flask Blueprints You can also use flask_typed_routes with Flask Blueprints. Now let's update the items.py file with: import flask import flask_typed_routes as ftr app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) blp = flask.Blueprint('items', __name__, url_prefix='/v2') @blp.get('/items/') def get_items_v2(skip: int = 0, limit: int = 10, country: str = 'US'): data = {'skip': skip, 'limit': limit, 'country': country} return flask.jsonify(data) app.register_blueprint(blp) Using Flask Class-Based Views You can also use flask_typed_routes with Flask Class-Based Views. Now let's update the items.py file with: import flask import flask.views import flask_typed_routes as ftr app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) class UserProducts(flask.views.View): def dispatch_request(self, user: str, skip: int = 0, limit: int = 10): data = {'user': user, 'skip': skip, 'limit': limit} return flask.jsonify(data) class UserOrders(flask.views.MethodView): def get(self, user: str, skip: int = 0, limit: int = 10): data = {'user': user, 'skip': skip, 'limit': limit} return flask.jsonify(data) app.add_url_rule('/products/<user>/all/', view_func=UserProducts.as_view('user_products')) app.add_url_rule('/orders/<user>/all/', view_func=UserOrders.as_view('user_orders'))","title":"Introduction"},{"location":"#about","text":"flask_typed_routes is a Flask extension designed to validate requests effortlessly with Pydantic .","title":"About"},{"location":"#features","text":"\ud83c\udfaf Type Safety: Automatically validates requests based on standard Python type hints. \ud83d\udd0c Easy Integration: Simple Flask extension for applying validation to Flask routes. \u26a0\ufe0f Error Handling: Automatically returns meaningful error responses for validation failures. \u2728 Autocomplete : Excellent editor integration, offering comprehensive completion across all contexts.","title":"Features"},{"location":"#requirements","text":"Python 3.10+ Pydantic 2.0+ Flask","title":"Requirements"},{"location":"#installation","text":"To install flask_typed_routes using pip , run the following command: pip install flask_typed_routes","title":"Installation"},{"location":"#getting-started","text":"This tool offers comprehensive validation for various types of request parameters, including Path, Query, Body, Header, and Cookie parameters. Example of a simple Flask application using flask_typed_routes : Create a file items.py with: import typing as t import annotated_types as at import flask import flask_typed_routes as ftr import pydantic app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) Skip = pydantic.NonNegativeInt # custom Pydantic type Limit = t.Annotated[int, at.Ge(1), at.Le(100)] # custom Annotated type @app.get('/items/<user>/') def get_items(user: str, skip: Skip = 0, limit: Limit = 10): # Parameters not included in the \"path\" are automatically treated as \"query\" parameters. data = { 'user': user, 'skip': skip, 'limit': limit, } return flask.jsonify(data) Run the server with: flask --app items run --debug Open your browser and go to http://127.0.0.1:5000/items/myuser/?skip=20 You will see the JSON response as: { \"limit\": 10, \"skip\": 20, \"user\": \"myuser\" } Validation: Open your browser and go to http://127.0.0.1:5000/items/myuser/?skip=abc You will see the JSON response with the error details because the skip parameter is not an integer: { \"errors\": [ { \"input\": \"abc\", \"loc\": [ \"query\", \"skip\" ], \"msg\": \"Input should be a valid integer, unable to parse string as an integer\", \"type\": \"int_parsing\", \"url\": \"https://errors.pydantic.dev/2.9/v/int_parsing\" } ] }","title":"Getting Started"},{"location":"#example-with-pydantic-models","text":"You can also use Pydantic models to validate request data in Flask routes. Now let's update the items.py file with: import flask import flask_typed_routes as ftr import pydantic app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) class Item(pydantic.BaseModel): name: str description: str = None price: float @app.post('/items/') def create_item(item: Item): return flask.jsonify(item.model_dump()) @app.put('/items/<item_id>/') def update_item(item_id: int, item: Item): return flask.jsonify({'item_id': item_id, **item.model_dump()})","title":"Example with Pydantic Models"},{"location":"#using-flask-blueprints","text":"You can also use flask_typed_routes with Flask Blueprints. Now let's update the items.py file with: import flask import flask_typed_routes as ftr app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) blp = flask.Blueprint('items', __name__, url_prefix='/v2') @blp.get('/items/') def get_items_v2(skip: int = 0, limit: int = 10, country: str = 'US'): data = {'skip': skip, 'limit': limit, 'country': country} return flask.jsonify(data) app.register_blueprint(blp)","title":"Using Flask Blueprints"},{"location":"#using-flask-class-based-views","text":"You can also use flask_typed_routes with Flask Class-Based Views. Now let's update the items.py file with: import flask import flask.views import flask_typed_routes as ftr app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) class UserProducts(flask.views.View): def dispatch_request(self, user: str, skip: int = 0, limit: int = 10): data = {'user': user, 'skip': skip, 'limit': limit} return flask.jsonify(data) class UserOrders(flask.views.MethodView): def get(self, user: str, skip: int = 0, limit: int = 10): data = {'user': user, 'skip': skip, 'limit': limit} return flask.jsonify(data) app.add_url_rule('/products/<user>/all/', view_func=UserProducts.as_view('user_products')) app.add_url_rule('/orders/<user>/all/', view_func=UserOrders.as_view('user_orders'))","title":"Using Flask Class-Based Views"},{"location":"body/","text":"Request Body To declare a request body, you use Pydantic models with all their power and benefits By default, the library interprets a Pydantic model used as a type annotation in a function signature as a request body model. However, if you only want to validate specific fields in the request body, you can use the Body Field annotation. Note This Body Field is an extension of Pydantic's field Basic Usage of request Body Validation: import typing as t import pydantic import flask import flask_typed_routes as flask_tpr app = flask.Flask(__name__) flask_tpr.FlaskTypedRoutes(app) class Item(pydantic.BaseModel): title: str author: str @app.post('/items/') def create_item(item: Item): # Use Pydantic model to validate the request body return flask.jsonify(item.model_dump()) @app.put('/items/<item_id>/') def update_item( item_id: int, title: t.Annotated[str, flask_tpr.Body()] = None, author: t.Annotated[str, flask_tpr.Body()] = None, ): # Use `Body` to validate specific fields in the request body data = { 'item_id': item_id, 'title': title, 'author': author, } return flask.jsonify(data) Explanation: Item : Pydantic model that represents the structure of the request body. The model has two fields: title and author . create_item : Route that accepts a POST request with a JSON body that must match the Item model. update_item : Route that accepts a URL parameter item_id that must be an integer. The route also accepts two optional JSON body parameters: title and author . The parameters are validated using the library field Body . Create a new Item: Invalid request Body POST http://127.0.0.1:5000/items/ { \"title\": \"Hello, World!\" } Http Response: { \"errors\": [ { \"input\": { \"title\": \"Hello, World!\" }, \"loc\": [ \"body\", \"author\" ], \"msg\": \"Field required\", \"type\": \"missing\", \"url\": \"https://errors.pydantic.dev/2.9/v/missing\" } ] } Update an Item: Invalid request Body PUT http://127.0.0.1:5000/items/123 { \"title\": 111 } Http Response: { \"errors\": [ { \"input\": 111, \"loc\": [ \"body\", \"title\" ], \"msg\": \"Input should be a valid string\", \"type\": \"string_type\", \"url\": \"https://errors.pydantic.dev/2.9/v/string_type\" } ] } Multiple Pydantic Models You can use multiple Pydantic models in a single route and validate specific fields in the request body using the Body field with the embed parameter. import typing as t import pydantic import flask import flask_typed_routes as ftr app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) class Item(pydantic.BaseModel): title: str author: str class User(pydantic.BaseModel): email: str age: int @app.post('/users/<user_id>/items/') def create_item_by_user( user_id: int, item: t.Annotated[Item, ftr.Body(embed=True)], user: t.Annotated[User, ftr.Body(embed=True)], ): # Use `Body` with `embed=True` to validate nested specific fields in the request body data = { 'user_id': user_id, 'item': item.model_dump(), 'user': user.model_dump(), } return flask.jsonify(data) Example request: POST http://127.0.0.1:5000/users/123/items/ { \"item\": { \"title\": \"Hello, World!\", \"author\": \"John Doe\" }, \"user\": { \"email\": \"myemail@abc.com\", \"age\": 25 } }","title":"Request body"},{"location":"body/#request-body","text":"To declare a request body, you use Pydantic models with all their power and benefits By default, the library interprets a Pydantic model used as a type annotation in a function signature as a request body model. However, if you only want to validate specific fields in the request body, you can use the Body Field annotation. Note This Body Field is an extension of Pydantic's field Basic Usage of request Body Validation: import typing as t import pydantic import flask import flask_typed_routes as flask_tpr app = flask.Flask(__name__) flask_tpr.FlaskTypedRoutes(app) class Item(pydantic.BaseModel): title: str author: str @app.post('/items/') def create_item(item: Item): # Use Pydantic model to validate the request body return flask.jsonify(item.model_dump()) @app.put('/items/<item_id>/') def update_item( item_id: int, title: t.Annotated[str, flask_tpr.Body()] = None, author: t.Annotated[str, flask_tpr.Body()] = None, ): # Use `Body` to validate specific fields in the request body data = { 'item_id': item_id, 'title': title, 'author': author, } return flask.jsonify(data) Explanation: Item : Pydantic model that represents the structure of the request body. The model has two fields: title and author . create_item : Route that accepts a POST request with a JSON body that must match the Item model. update_item : Route that accepts a URL parameter item_id that must be an integer. The route also accepts two optional JSON body parameters: title and author . The parameters are validated using the library field Body . Create a new Item: Invalid request Body POST http://127.0.0.1:5000/items/ { \"title\": \"Hello, World!\" } Http Response: { \"errors\": [ { \"input\": { \"title\": \"Hello, World!\" }, \"loc\": [ \"body\", \"author\" ], \"msg\": \"Field required\", \"type\": \"missing\", \"url\": \"https://errors.pydantic.dev/2.9/v/missing\" } ] } Update an Item: Invalid request Body PUT http://127.0.0.1:5000/items/123 { \"title\": 111 } Http Response: { \"errors\": [ { \"input\": 111, \"loc\": [ \"body\", \"title\" ], \"msg\": \"Input should be a valid string\", \"type\": \"string_type\", \"url\": \"https://errors.pydantic.dev/2.9/v/string_type\" } ] }","title":"Request Body"},{"location":"body/#multiple-pydantic-models","text":"You can use multiple Pydantic models in a single route and validate specific fields in the request body using the Body field with the embed parameter. import typing as t import pydantic import flask import flask_typed_routes as ftr app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) class Item(pydantic.BaseModel): title: str author: str class User(pydantic.BaseModel): email: str age: int @app.post('/users/<user_id>/items/') def create_item_by_user( user_id: int, item: t.Annotated[Item, ftr.Body(embed=True)], user: t.Annotated[User, ftr.Body(embed=True)], ): # Use `Body` with `embed=True` to validate nested specific fields in the request body data = { 'user_id': user_id, 'item': item.model_dump(), 'user': user.model_dump(), } return flask.jsonify(data) Example request: POST http://127.0.0.1:5000/users/123/items/ { \"item\": { \"title\": \"Hello, World!\", \"author\": \"John Doe\" }, \"user\": { \"email\": \"myemail@abc.com\", \"age\": 25 } }","title":"Multiple Pydantic Models"},{"location":"cookie/","text":"Cookie Parameters You can define cookie parameters in the same way as query parameters , with support for multiple values and validation using Pydantic models. import typing as t import flask import flask_typed_routes as ftr app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) SessionId = t.Annotated[str, ftr.Cookie(alias=\"session-id\")] @app.route('/items/') def get_items(session_id: SessionId = None): data = { 'session_id': session_id, } return flask.jsonify(data)","title":"Cookie parameters"},{"location":"cookie/#cookie-parameters","text":"You can define cookie parameters in the same way as query parameters , with support for multiple values and validation using Pydantic models. import typing as t import flask import flask_typed_routes as ftr app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) SessionId = t.Annotated[str, ftr.Cookie(alias=\"session-id\")] @app.route('/items/') def get_items(session_id: SessionId = None): data = { 'session_id': session_id, } return flask.jsonify(data)","title":"Cookie Parameters"},{"location":"errors/","text":"Handling Errors If you need to change default output for validation errors, you can pass a custom error handler to FlaskTypedRoutes constructor. import flask import flask_typed_routes as flask_tpr app = flask.Flask(__name__) def custom_error_handler(error): return flask.jsonify({\"detail\": error.errors}), 400 flask_tpr.FlaskTypedRoutes(app, validation_error_handler=custom_error_handler)","title":"Handling errors"},{"location":"errors/#handling-errors","text":"If you need to change default output for validation errors, you can pass a custom error handler to FlaskTypedRoutes constructor. import flask import flask_typed_routes as flask_tpr app = flask.Flask(__name__) def custom_error_handler(error): return flask.jsonify({\"detail\": error.errors}), 400 flask_tpr.FlaskTypedRoutes(app, validation_error_handler=custom_error_handler)","title":"Handling Errors"},{"location":"header/","text":"Header parameters You can define header parameters in the same way as query/cookie parameters , with support for multiple values and validation using Pydantic models. import typing as t import flask import flask_typed_routes as ftr app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) @app.route('/items/') def get_items(auth: t.Annotated[str, ftr.Header(alias=\"Authorization\")] = None): data = { 'auth': auth, } return flask.jsonify(data)","title":"Header parameters"},{"location":"header/#header-parameters","text":"You can define header parameters in the same way as query/cookie parameters , with support for multiple values and validation using Pydantic models. import typing as t import flask import flask_typed_routes as ftr app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) @app.route('/items/') def get_items(auth: t.Annotated[str, ftr.Header(alias=\"Authorization\")] = None): data = { 'auth': auth, } return flask.jsonify(data)","title":"Header parameters"},{"location":"path/","text":"Path Parameters You can validate Path parameters in your route by adding standard type hints to the function signature. Warning If no type hint is provided, the Path parameters are not validated. import typing as t import flask import flask_typed_routes as ftr app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) @app.route('/items/<category_id>/<lang>/') def read_items(category_id: int, lang: t.Literal['es', 'en']): data = {'category_id': category_id, 'lang': lang} return flask.jsonify(data) Conversion: The library automatically converts path parameters to their specified types: category_id is converted to an integer, so your function receives it as an integer. lang is treated as a string, so your function receives it as a string. Validation: category_id Must be an integer. lang Must be either 'es' or 'en'. Example request: GET http://127.0.0.1:5000/items/12/es { \"category_id\": 12, \"lang\": \"es\" } Bad request example: If category_id is not an integer GET http://127.0.0.1:5000/items/abc/es { \"errors\": [ { \"input\": \"abc\", \"loc\": [ \"path\", \"category_id\" ], \"msg\": \"Input should be a valid integer, unable to parse string as an integer\", \"type\": \"int_parsing\", \"url\": \"https://errors.pydantic.dev/2.9/v/int_parsing\" } ] } Additional validations You can leverage Pydantic's custom types or define your own custom data types to apply additional validation to your path parameters. import typing as t import annotated_types as at import flask import flask_typed_routes as ftr app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) @app.route('/items/<category_id>/') def read_items(category_id: t.Annotated[int, at.Ge(1), at.Le(100)]): data = {'category_id': category_id} return flask.jsonify(data) Alternatively, you can use the Path field. This field is an extension of Pydantic's field , offering powerful validation capabilities. This flexibility allows you to tailor path parameter validation to your application's specific needs. import typing as t import flask import flask_typed_routes as ftr app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) @app.route('/items/<category_id>/') def read_items(category_id: t.Annotated[int, ftr.Path(ge=1, le=100)]): data = {'category_id': category_id} return flask.jsonify(data) Validation: category_id must be an integer between 1 and 100. Aliasing Warning Aliases defined in Path type hints will be ignored to maintain consistency with the names specified in the Flask route.","title":"Path parameters"},{"location":"path/#path-parameters","text":"You can validate Path parameters in your route by adding standard type hints to the function signature. Warning If no type hint is provided, the Path parameters are not validated. import typing as t import flask import flask_typed_routes as ftr app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) @app.route('/items/<category_id>/<lang>/') def read_items(category_id: int, lang: t.Literal['es', 'en']): data = {'category_id': category_id, 'lang': lang} return flask.jsonify(data) Conversion: The library automatically converts path parameters to their specified types: category_id is converted to an integer, so your function receives it as an integer. lang is treated as a string, so your function receives it as a string. Validation: category_id Must be an integer. lang Must be either 'es' or 'en'. Example request: GET http://127.0.0.1:5000/items/12/es { \"category_id\": 12, \"lang\": \"es\" } Bad request example: If category_id is not an integer GET http://127.0.0.1:5000/items/abc/es { \"errors\": [ { \"input\": \"abc\", \"loc\": [ \"path\", \"category_id\" ], \"msg\": \"Input should be a valid integer, unable to parse string as an integer\", \"type\": \"int_parsing\", \"url\": \"https://errors.pydantic.dev/2.9/v/int_parsing\" } ] }","title":"Path Parameters"},{"location":"path/#additional-validations","text":"You can leverage Pydantic's custom types or define your own custom data types to apply additional validation to your path parameters. import typing as t import annotated_types as at import flask import flask_typed_routes as ftr app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) @app.route('/items/<category_id>/') def read_items(category_id: t.Annotated[int, at.Ge(1), at.Le(100)]): data = {'category_id': category_id} return flask.jsonify(data) Alternatively, you can use the Path field. This field is an extension of Pydantic's field , offering powerful validation capabilities. This flexibility allows you to tailor path parameter validation to your application's specific needs. import typing as t import flask import flask_typed_routes as ftr app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) @app.route('/items/<category_id>/') def read_items(category_id: t.Annotated[int, ftr.Path(ge=1, le=100)]): data = {'category_id': category_id} return flask.jsonify(data) Validation: category_id must be an integer between 1 and 100.","title":"Additional validations"},{"location":"path/#aliasing","text":"Warning Aliases defined in Path type hints will be ignored to maintain consistency with the names specified in the Flask route.","title":"Aliasing"},{"location":"query/","text":"Query parameters Parameters not included in the Path are automatically treated as Query parameters. Required: Declared as function arguments without default values. Optional: Declared with default values. import flask import flask_typed_routes as ftr app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) @app.route('/items/') def get_items(needy: str, skip: int = 0, limit: int = 100): data = { 'needy': needy, 'skip': skip, 'limit': limit, } return flask.jsonify(data) Validation: needy : Required and must be a string. skip : Optional and must be an integer. If not included, it defaults to 0. limit : Optional and must be an integer. If not included, it defaults to 100. Example request: GET http://127.0.0.1:5000/items/?needy=passed&skip=20 { \"limit\": 100, \"needy\": \"passed\", \"skip\": 20 } Bad request example: If needy is not included in the request http://127.0.0.1:5000/items/ { \"errors\": [ { \"input\": {}, \"loc\": [ \"query\", \"needy\" ], \"msg\": \"Field required\", \"type\": \"missing\", \"url\": \"https://errors.pydantic.dev/2.9/v/missing\" } ] } Additional validations You can leverage Pydantic's custom types or define your own custom data types to apply additional validation to your query parameters. import typing as t import annotated_types as at import flask import pydantic import flask_typed_routes as ftr app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) # Custom Types for additional validation combining Pydantic and Annotated Needy = t.Annotated[str, at.MinLen(3), at.MaxLen(10)] Limit = t.Annotated[int, at.Ge(1), at.Le(100), pydantic.Field(alias=\"size\")] @app.route('/items/') def get_items(needy: Needy, skip: int = 0, limit: Limit = 100): data = { 'needy': needy, 'skip': skip, 'limit': limit, } return flask.jsonify(data) Alternatively, you can use the Query field. This field is an extension of Pydantic's field , offering powerful validation capabilities. This flexibility allows you to tailor query parameter validation to your application's specific needs. Tip The Query field is supported aliasing. You can use the alias argument to define the query parameter name in the request. import typing as t import flask import flask_typed_routes as ftr app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) Needy = t.Annotated[str, ftr.Query(min_length=3, max_length=10)] Limit = t.Annotated[int, ftr.Query(ge=1, le=100, alias=\"size\")] @app.route('/items/') def get_items(needy: Needy, skip: int = 0, limit: Limit = 100): data = { 'needy': needy, 'skip': skip, 'limit': limit, } return flask.jsonify(data) Validation: needy : Required and must be a string between 3 and 10 characters. skip : Optional and must be an integer. limit : Optional and must be an integer between 1 and 100, and must be named size in the request. Example request: GET http://127.0.0.1:5000/items/?needy=passed&size=20 { \"limit\": 20, \"needy\": \"passed\", \"skip\": 0 } Pydantic models If you have a group of query parameters that are related, you can create a Pydantic model to declare them. This would allow you to re-use the model in multiple places and also to declare validations and metadata for all the parameters at once. import typing as t import pydantic import flask import flask_typed_routes as ftr app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) class QueryParams(pydantic.BaseModel): status: bool skip: int = 0 limit: int = 10 tracking_number: t.Annotated[int, pydantic.Field(alias=\"tracking\", le=3)] = 1 payment_method: t.Literal[\"cash\", \"credit\"] = \"credit\" @app.get('/orders/<user_id>/') def get_orders( user_id: int, params: t.Annotated[QueryParams, ftr.Query()] ): data = {'user_id': user_id, \"params\": params.model_dump()} return flask.jsonify(data) Warning The Query field can only be directly specified in the function signature . When using Pydantic models, you must use Pydantic's fields . Example request: GET ttp://127.0.0.1:5000/orders/233/?status=true { \"params\": { \"limit\": 10, \"payment_method\": \"credit\", \"skip\": 0, \"status\": true, \"tracking_number\": 1 }, \"user_id\": 233 } Multiple values If you want to allow a query parameter to have multiple values, you can use the multi=True argument in the Query field. import typing as t import flask import flask_typed_routes as ftr app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) Tags = t.Annotated[list[str], ftr.Query(alias=\"tag\", multi=True)] @app.get('/users/<user_id>/') def get_users(user_id: int, tags: Tags = ()): data = {'user_id': user_id, \"tags\": tags} return flask.jsonify(data) Example request: GET http://127.0.0.1:5000/users/123/?tag=hello&tag=world { \"tags\": [ \"hello\", \"world\" ], \"user_id\": 123 }","title":"Query parameters"},{"location":"query/#query-parameters","text":"Parameters not included in the Path are automatically treated as Query parameters. Required: Declared as function arguments without default values. Optional: Declared with default values. import flask import flask_typed_routes as ftr app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) @app.route('/items/') def get_items(needy: str, skip: int = 0, limit: int = 100): data = { 'needy': needy, 'skip': skip, 'limit': limit, } return flask.jsonify(data) Validation: needy : Required and must be a string. skip : Optional and must be an integer. If not included, it defaults to 0. limit : Optional and must be an integer. If not included, it defaults to 100. Example request: GET http://127.0.0.1:5000/items/?needy=passed&skip=20 { \"limit\": 100, \"needy\": \"passed\", \"skip\": 20 } Bad request example: If needy is not included in the request http://127.0.0.1:5000/items/ { \"errors\": [ { \"input\": {}, \"loc\": [ \"query\", \"needy\" ], \"msg\": \"Field required\", \"type\": \"missing\", \"url\": \"https://errors.pydantic.dev/2.9/v/missing\" } ] }","title":"Query parameters"},{"location":"query/#additional-validations","text":"You can leverage Pydantic's custom types or define your own custom data types to apply additional validation to your query parameters. import typing as t import annotated_types as at import flask import pydantic import flask_typed_routes as ftr app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) # Custom Types for additional validation combining Pydantic and Annotated Needy = t.Annotated[str, at.MinLen(3), at.MaxLen(10)] Limit = t.Annotated[int, at.Ge(1), at.Le(100), pydantic.Field(alias=\"size\")] @app.route('/items/') def get_items(needy: Needy, skip: int = 0, limit: Limit = 100): data = { 'needy': needy, 'skip': skip, 'limit': limit, } return flask.jsonify(data) Alternatively, you can use the Query field. This field is an extension of Pydantic's field , offering powerful validation capabilities. This flexibility allows you to tailor query parameter validation to your application's specific needs. Tip The Query field is supported aliasing. You can use the alias argument to define the query parameter name in the request. import typing as t import flask import flask_typed_routes as ftr app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) Needy = t.Annotated[str, ftr.Query(min_length=3, max_length=10)] Limit = t.Annotated[int, ftr.Query(ge=1, le=100, alias=\"size\")] @app.route('/items/') def get_items(needy: Needy, skip: int = 0, limit: Limit = 100): data = { 'needy': needy, 'skip': skip, 'limit': limit, } return flask.jsonify(data) Validation: needy : Required and must be a string between 3 and 10 characters. skip : Optional and must be an integer. limit : Optional and must be an integer between 1 and 100, and must be named size in the request. Example request: GET http://127.0.0.1:5000/items/?needy=passed&size=20 { \"limit\": 20, \"needy\": \"passed\", \"skip\": 0 }","title":"Additional validations"},{"location":"query/#pydantic-models","text":"If you have a group of query parameters that are related, you can create a Pydantic model to declare them. This would allow you to re-use the model in multiple places and also to declare validations and metadata for all the parameters at once. import typing as t import pydantic import flask import flask_typed_routes as ftr app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) class QueryParams(pydantic.BaseModel): status: bool skip: int = 0 limit: int = 10 tracking_number: t.Annotated[int, pydantic.Field(alias=\"tracking\", le=3)] = 1 payment_method: t.Literal[\"cash\", \"credit\"] = \"credit\" @app.get('/orders/<user_id>/') def get_orders( user_id: int, params: t.Annotated[QueryParams, ftr.Query()] ): data = {'user_id': user_id, \"params\": params.model_dump()} return flask.jsonify(data) Warning The Query field can only be directly specified in the function signature . When using Pydantic models, you must use Pydantic's fields . Example request: GET ttp://127.0.0.1:5000/orders/233/?status=true { \"params\": { \"limit\": 10, \"payment_method\": \"credit\", \"skip\": 0, \"status\": true, \"tracking_number\": 1 }, \"user_id\": 233 }","title":"Pydantic models"},{"location":"query/#multiple-values","text":"If you want to allow a query parameter to have multiple values, you can use the multi=True argument in the Query field. import typing as t import flask import flask_typed_routes as ftr app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) Tags = t.Annotated[list[str], ftr.Query(alias=\"tag\", multi=True)] @app.get('/users/<user_id>/') def get_users(user_id: int, tags: Tags = ()): data = {'user_id': user_id, \"tags\": tags} return flask.jsonify(data) Example request: GET http://127.0.0.1:5000/users/123/?tag=hello&tag=world { \"tags\": [ \"hello\", \"world\" ], \"user_id\": 123 }","title":"Multiple values"}]}