{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"About flask_typed_routes is a Flask extension designed to effortlessly validate requests with Pydantic based on standard Python type hints. Documentation : https://rmoralespp.github.io/flask_typed_routes/ Features \ud83c\udfaf Type Safety: Automatically validates requests using Python type hints. \ud83d\udd0c Easy Integration: Simple extension for validating Flask routes. \u26a0\ufe0f Error Handling: Clear and automatic responses for validation failures. \u2728 Autocomplete: Editor integration with comprehensive suggestions. \u2699\ufe0f Validation Modes: Supports automatic validation for all routes and manual validation for specific routes using decorators. \ud83d\udcd6 OpenAPI Support: Automatically generates an OpenAPI schema, ensuring clear documentation and seamless integration with OpenAPI tools. Requirements Python 3.10+ Pydantic 2.0+ Flask Installation To install flask_typed_routes using pip , run the following command: pip install flask_typed_routes Getting Started This tool offers comprehensive validation for various types of request parameters, including Path, Query, Body, Header, and Cookie parameters. Example of a simple Flask application using flask_typed_routes : Create a file items.py with: Note The FlaskTypedRoutes class must be initialized before registering the Flask routes and blueprints to allow the extension to collect the routes and be able to validate the endpoints. import typing as t import annotated_types as at import flask import flask_typed_routes as ftr import pydantic app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) Skip = pydantic.NonNegativeInt # custom Pydantic type Limit = t.Annotated[int, at.Ge(1), at.Le(100)] # custom Annotated type @app.get('/items/<user>/') def read_items(user: str, skip: Skip = 0, limit: Limit = 10): # Parameters not included in the \"path\" are automatically treated as \"query\" parameters. data = { 'user': user, 'skip': skip, 'limit': limit, } return flask.jsonify(data) Run the server with: flask --app items run --debug Open your browser and go to http://127.0.0.1:5000/items/myuser/?skip=20 You will see the JSON response as: { \"limit\": 10, \"skip\": 20, \"user\": \"myuser\" } Validation: Open your browser and go to http://127.0.0.1:5000/items/myuser/?skip=abc You will see the JSON response with the error details because the skip parameter is not an integer: { \"errors\": [ { \"input\": \"abc\", \"loc\": [ \"query\", \"skip\" ], \"msg\": \"Input should be a valid integer, unable to parse string as an integer\", \"type\": \"int_parsing\", \"url\": \"https://errors.pydantic.dev/2.9/v/int_parsing\" } ] } Example with Pydantic Models You can also use Pydantic models to validate request data in Flask routes. Now let's update the items.py file with: import pydantic import flask import flask_typed_routes as ftr app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) class Item(pydantic.BaseModel): name: str description: str = None price: float @app.post('/items/') def create_item(item: Item): return flask.jsonify(item.model_dump()) @app.put('/items/<item_id>/') def update_item(item_id: int, item: Item): return flask.jsonify({'item_id': item_id, **item.model_dump()}) Using Flask Blueprints You can also use flask_typed_routes with Flask Blueprints. Now let's update the items.py file with: import flask import flask_typed_routes as ftr app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) blp = flask.Blueprint('items', __name__, url_prefix='/v2') @blp.get('/items/') def read_items(skip: int = 0, limit: int = 10, country: str = 'US'): data = {'skip': skip, 'limit': limit, 'country': country} return flask.jsonify(data) app.register_blueprint(blp) Using Flask Class-Based Views You can also use flask_typed_routes with Flask Class-Based Views. Now let's update the items.py file with: import flask import flask.views import flask_typed_routes as ftr app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) class UserProducts(flask.views.View): def dispatch_request(self, user: str, skip: int = 0, limit: int = 10): data = {'user': user, 'skip': skip, 'limit': limit} return flask.jsonify(data) class UserOrders(flask.views.MethodView): def get(self, user: str, skip: int = 0, limit: int = 10): data = {'user': user, 'skip': skip, 'limit': limit} return flask.jsonify(data) app.add_url_rule('/products/<user>/', view_func=UserProducts.as_view('user_products')) app.add_url_rule('/orders/<user>/', view_func=UserOrders.as_view('user_orders')) Interactive API docs You can OpenApi schema generated by flask_typed_routes with any OpenApi tools to generate interactive API docs for your Flask application. In this example we will use the swagger-ui-py library. pip install swagger-ui-py # ignore if already installed import flask import pydantic import swagger_ui import flask_typed_routes as ftr app = flask.Flask(__name__) app_ftr = ftr.FlaskTypedRoutes(app) class Item(pydantic.BaseModel): name: str description: str = None price: float @app.get('/items/<user>/') def read_items(user: str, skip: int = 0, limit: int = 10): data = {'user': user, 'skip': skip, 'limit': limit} return flask.jsonify(data) @app.post('/items/') def create_item(item: Item): return flask.jsonify(item.model_dump()) @app.put('/items/<item_id>/') def update_item(item_id: int, item: Item): return flask.jsonify({'item_id': item_id, **item.model_dump()}) @app.delete('/items/<item_id>/') def remove_item(item_id: int): return flask.jsonify({'item_id': item_id}) # Get the OpenAPI schema from the `FlaskTypedRoutes` instance after registering the routes and blueprints, # as the extension first needs to collect the routes to generate the OpenAPI schema. swagger_ui.api_doc(app, config=app_ftr.get_openapi_schema(), url_prefix='/docs') Open your browser and go to http://127.0.0.1:5000/docs/ Create item endpoint: Read Items endpoint:","title":"Introduction"},{"location":"#about","text":"flask_typed_routes is a Flask extension designed to effortlessly validate requests with Pydantic based on standard Python type hints. Documentation : https://rmoralespp.github.io/flask_typed_routes/","title":"About"},{"location":"#features","text":"\ud83c\udfaf Type Safety: Automatically validates requests using Python type hints. \ud83d\udd0c Easy Integration: Simple extension for validating Flask routes. \u26a0\ufe0f Error Handling: Clear and automatic responses for validation failures. \u2728 Autocomplete: Editor integration with comprehensive suggestions. \u2699\ufe0f Validation Modes: Supports automatic validation for all routes and manual validation for specific routes using decorators. \ud83d\udcd6 OpenAPI Support: Automatically generates an OpenAPI schema, ensuring clear documentation and seamless integration with OpenAPI tools.","title":"Features"},{"location":"#requirements","text":"Python 3.10+ Pydantic 2.0+ Flask","title":"Requirements"},{"location":"#installation","text":"To install flask_typed_routes using pip , run the following command: pip install flask_typed_routes","title":"Installation"},{"location":"#getting-started","text":"This tool offers comprehensive validation for various types of request parameters, including Path, Query, Body, Header, and Cookie parameters. Example of a simple Flask application using flask_typed_routes : Create a file items.py with: Note The FlaskTypedRoutes class must be initialized before registering the Flask routes and blueprints to allow the extension to collect the routes and be able to validate the endpoints. import typing as t import annotated_types as at import flask import flask_typed_routes as ftr import pydantic app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) Skip = pydantic.NonNegativeInt # custom Pydantic type Limit = t.Annotated[int, at.Ge(1), at.Le(100)] # custom Annotated type @app.get('/items/<user>/') def read_items(user: str, skip: Skip = 0, limit: Limit = 10): # Parameters not included in the \"path\" are automatically treated as \"query\" parameters. data = { 'user': user, 'skip': skip, 'limit': limit, } return flask.jsonify(data) Run the server with: flask --app items run --debug Open your browser and go to http://127.0.0.1:5000/items/myuser/?skip=20 You will see the JSON response as: { \"limit\": 10, \"skip\": 20, \"user\": \"myuser\" } Validation: Open your browser and go to http://127.0.0.1:5000/items/myuser/?skip=abc You will see the JSON response with the error details because the skip parameter is not an integer: { \"errors\": [ { \"input\": \"abc\", \"loc\": [ \"query\", \"skip\" ], \"msg\": \"Input should be a valid integer, unable to parse string as an integer\", \"type\": \"int_parsing\", \"url\": \"https://errors.pydantic.dev/2.9/v/int_parsing\" } ] }","title":"Getting Started"},{"location":"#example-with-pydantic-models","text":"You can also use Pydantic models to validate request data in Flask routes. Now let's update the items.py file with: import pydantic import flask import flask_typed_routes as ftr app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) class Item(pydantic.BaseModel): name: str description: str = None price: float @app.post('/items/') def create_item(item: Item): return flask.jsonify(item.model_dump()) @app.put('/items/<item_id>/') def update_item(item_id: int, item: Item): return flask.jsonify({'item_id': item_id, **item.model_dump()})","title":"Example with Pydantic Models"},{"location":"#using-flask-blueprints","text":"You can also use flask_typed_routes with Flask Blueprints. Now let's update the items.py file with: import flask import flask_typed_routes as ftr app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) blp = flask.Blueprint('items', __name__, url_prefix='/v2') @blp.get('/items/') def read_items(skip: int = 0, limit: int = 10, country: str = 'US'): data = {'skip': skip, 'limit': limit, 'country': country} return flask.jsonify(data) app.register_blueprint(blp)","title":"Using Flask Blueprints"},{"location":"#using-flask-class-based-views","text":"You can also use flask_typed_routes with Flask Class-Based Views. Now let's update the items.py file with: import flask import flask.views import flask_typed_routes as ftr app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) class UserProducts(flask.views.View): def dispatch_request(self, user: str, skip: int = 0, limit: int = 10): data = {'user': user, 'skip': skip, 'limit': limit} return flask.jsonify(data) class UserOrders(flask.views.MethodView): def get(self, user: str, skip: int = 0, limit: int = 10): data = {'user': user, 'skip': skip, 'limit': limit} return flask.jsonify(data) app.add_url_rule('/products/<user>/', view_func=UserProducts.as_view('user_products')) app.add_url_rule('/orders/<user>/', view_func=UserOrders.as_view('user_orders'))","title":"Using Flask Class-Based Views"},{"location":"#interactive-api-docs","text":"You can OpenApi schema generated by flask_typed_routes with any OpenApi tools to generate interactive API docs for your Flask application. In this example we will use the swagger-ui-py library. pip install swagger-ui-py # ignore if already installed import flask import pydantic import swagger_ui import flask_typed_routes as ftr app = flask.Flask(__name__) app_ftr = ftr.FlaskTypedRoutes(app) class Item(pydantic.BaseModel): name: str description: str = None price: float @app.get('/items/<user>/') def read_items(user: str, skip: int = 0, limit: int = 10): data = {'user': user, 'skip': skip, 'limit': limit} return flask.jsonify(data) @app.post('/items/') def create_item(item: Item): return flask.jsonify(item.model_dump()) @app.put('/items/<item_id>/') def update_item(item_id: int, item: Item): return flask.jsonify({'item_id': item_id, **item.model_dump()}) @app.delete('/items/<item_id>/') def remove_item(item_id: int): return flask.jsonify({'item_id': item_id}) # Get the OpenAPI schema from the `FlaskTypedRoutes` instance after registering the routes and blueprints, # as the extension first needs to collect the routes to generate the OpenAPI schema. swagger_ui.api_doc(app, config=app_ftr.get_openapi_schema(), url_prefix='/docs') Open your browser and go to http://127.0.0.1:5000/docs/ Create item endpoint: Read Items endpoint:","title":"Interactive API docs"},{"location":"body/","text":"Request Body To declare a request body, you use Pydantic models with all their power and benefits By default, the library interprets a Pydantic model used as a type annotation in a function signature as a request body model. However, if you only want to validate specific fields in the request body, you can use the Body Field annotation. Note This Body Field is an extension of Pydantic's field Basic Usage of request Body Validation: import typing as t import pydantic import flask import flask_typed_routes as flask_tpr app = flask.Flask(__name__) flask_tpr.FlaskTypedRoutes(app) class Item(pydantic.BaseModel): title: str author: str @app.post('/items/') def create_item(item: Item): # Use Pydantic model to validate the request body return flask.jsonify(item.model_dump()) @app.put('/items/<item_id>/') def update_item( item_id: int, title: t.Annotated[str, flask_tpr.Body()] = None, author: t.Annotated[str, flask_tpr.Body()] = None, ): # Use `Body` to validate specific fields in the request body data = { 'item_id': item_id, 'title': title, 'author': author, } return flask.jsonify(data) Explanation: Item : Pydantic model that represents the structure of the request body. The model has two fields: title and author . create_item : Route that accepts a POST request with a JSON body that must match the Item model. update_item : Route that accepts a URL parameter item_id that must be an integer. The route also accepts two optional JSON body parameters: title and author . The parameters are validated using the library field Body . Create a new Item: Invalid request Body POST http://127.0.0.1:5000/items/ { \"title\": \"Hello, World!\" } Http Response: { \"errors\": [ { \"input\": { \"title\": \"Hello, World!\" }, \"loc\": [ \"body\", \"author\" ], \"msg\": \"Field required\", \"type\": \"missing\", \"url\": \"https://errors.pydantic.dev/2.9/v/missing\" } ] } Update an Item: Invalid request Body PUT http://127.0.0.1:5000/items/123 { \"title\": 111 } Http Response: { \"errors\": [ { \"input\": 111, \"loc\": [ \"body\", \"title\" ], \"msg\": \"Input should be a valid string\", \"type\": \"string_type\", \"url\": \"https://errors.pydantic.dev/2.9/v/string_type\" } ] } Multiple Pydantic Models You can use multiple Pydantic models in a single route and validate specific fields in the request body using the Body field with the embed parameter. import typing as t import pydantic import flask import flask_typed_routes as ftr app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) class Item(pydantic.BaseModel): title: str author: str class User(pydantic.BaseModel): email: str age: int @app.post('/users/<user_id>/items/') def create_item_by_user( user_id: int, item: t.Annotated[Item, ftr.Body(embed=True)], user: t.Annotated[User, ftr.Body(embed=True)], ): # Use `Body` with `embed=True` to validate nested specific fields in the request body data = { 'user_id': user_id, 'item': item.model_dump(), 'user': user.model_dump(), } return flask.jsonify(data) Example request: POST http://127.0.0.1:5000/users/123/items/ { \"item\": { \"title\": \"Hello, World!\", \"author\": \"John Doe\" }, \"user\": { \"email\": \"myemail@abc.com\", \"age\": 25 } }","title":"Request body"},{"location":"body/#request-body","text":"To declare a request body, you use Pydantic models with all their power and benefits By default, the library interprets a Pydantic model used as a type annotation in a function signature as a request body model. However, if you only want to validate specific fields in the request body, you can use the Body Field annotation. Note This Body Field is an extension of Pydantic's field Basic Usage of request Body Validation: import typing as t import pydantic import flask import flask_typed_routes as flask_tpr app = flask.Flask(__name__) flask_tpr.FlaskTypedRoutes(app) class Item(pydantic.BaseModel): title: str author: str @app.post('/items/') def create_item(item: Item): # Use Pydantic model to validate the request body return flask.jsonify(item.model_dump()) @app.put('/items/<item_id>/') def update_item( item_id: int, title: t.Annotated[str, flask_tpr.Body()] = None, author: t.Annotated[str, flask_tpr.Body()] = None, ): # Use `Body` to validate specific fields in the request body data = { 'item_id': item_id, 'title': title, 'author': author, } return flask.jsonify(data) Explanation: Item : Pydantic model that represents the structure of the request body. The model has two fields: title and author . create_item : Route that accepts a POST request with a JSON body that must match the Item model. update_item : Route that accepts a URL parameter item_id that must be an integer. The route also accepts two optional JSON body parameters: title and author . The parameters are validated using the library field Body . Create a new Item: Invalid request Body POST http://127.0.0.1:5000/items/ { \"title\": \"Hello, World!\" } Http Response: { \"errors\": [ { \"input\": { \"title\": \"Hello, World!\" }, \"loc\": [ \"body\", \"author\" ], \"msg\": \"Field required\", \"type\": \"missing\", \"url\": \"https://errors.pydantic.dev/2.9/v/missing\" } ] } Update an Item: Invalid request Body PUT http://127.0.0.1:5000/items/123 { \"title\": 111 } Http Response: { \"errors\": [ { \"input\": 111, \"loc\": [ \"body\", \"title\" ], \"msg\": \"Input should be a valid string\", \"type\": \"string_type\", \"url\": \"https://errors.pydantic.dev/2.9/v/string_type\" } ] }","title":"Request Body"},{"location":"body/#multiple-pydantic-models","text":"You can use multiple Pydantic models in a single route and validate specific fields in the request body using the Body field with the embed parameter. import typing as t import pydantic import flask import flask_typed_routes as ftr app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) class Item(pydantic.BaseModel): title: str author: str class User(pydantic.BaseModel): email: str age: int @app.post('/users/<user_id>/items/') def create_item_by_user( user_id: int, item: t.Annotated[Item, ftr.Body(embed=True)], user: t.Annotated[User, ftr.Body(embed=True)], ): # Use `Body` with `embed=True` to validate nested specific fields in the request body data = { 'user_id': user_id, 'item': item.model_dump(), 'user': user.model_dump(), } return flask.jsonify(data) Example request: POST http://127.0.0.1:5000/users/123/items/ { \"item\": { \"title\": \"Hello, World!\", \"author\": \"John Doe\" }, \"user\": { \"email\": \"myemail@abc.com\", \"age\": 25 } }","title":"Multiple Pydantic Models"},{"location":"cookie/","text":"Cookie Parameters You can define cookie parameters in the same way as query parameters , with support for multiple values and validation using Pydantic models. import typing as t import flask import flask_typed_routes as ftr app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) SessionId = t.Annotated[str, ftr.Cookie(alias=\"session-id\")] @app.route('/items/') def get_items(session_id: SessionId = None): data = { 'session_id': session_id, } return flask.jsonify(data) Multiple Cookie Parameters Note Cookie fields always use the form style. An optional explode keyword controls the array and object serialization.","title":"Cookie parameters"},{"location":"cookie/#cookie-parameters","text":"You can define cookie parameters in the same way as query parameters , with support for multiple values and validation using Pydantic models. import typing as t import flask import flask_typed_routes as ftr app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) SessionId = t.Annotated[str, ftr.Cookie(alias=\"session-id\")] @app.route('/items/') def get_items(session_id: SessionId = None): data = { 'session_id': session_id, } return flask.jsonify(data)","title":"Cookie Parameters"},{"location":"cookie/#multiple-cookie-parameters","text":"Note Cookie fields always use the form style. An optional explode keyword controls the array and object serialization.","title":"Multiple Cookie Parameters"},{"location":"errors/","text":"Handling Errors If you need to change default output for validation errors, you can pass a custom error handler to FlaskTypedRoutes constructor. import flask import flask_typed_routes as flask_tpr app = flask.Flask(__name__) def custom_error_handler(error): return flask.jsonify({\"detail\": error.errors}), 400 flask_tpr.FlaskTypedRoutes(app, validation_error_handler=custom_error_handler)","title":"Handling errors"},{"location":"errors/#handling-errors","text":"If you need to change default output for validation errors, you can pass a custom error handler to FlaskTypedRoutes constructor. import flask import flask_typed_routes as flask_tpr app = flask.Flask(__name__) def custom_error_handler(error): return flask.jsonify({\"detail\": error.errors}), 400 flask_tpr.FlaskTypedRoutes(app, validation_error_handler=custom_error_handler)","title":"Handling Errors"},{"location":"header/","text":"Header parameters You can define header parameters in the same way as query/cookie parameters , with support for multiple values and validation using Pydantic models. import typing as t import flask import flask_typed_routes as ftr app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) @app.route('/items/') def get_items(auth: t.Annotated[str, ftr.Header(alias=\"Authorization\")] = None): data = { 'auth': auth, } return flask.jsonify(data) Multiple Header Parameters Note Header fields always use the simple style, that is, comma-separated values.","title":"Header parameters"},{"location":"header/#header-parameters","text":"You can define header parameters in the same way as query/cookie parameters , with support for multiple values and validation using Pydantic models. import typing as t import flask import flask_typed_routes as ftr app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) @app.route('/items/') def get_items(auth: t.Annotated[str, ftr.Header(alias=\"Authorization\")] = None): data = { 'auth': auth, } return flask.jsonify(data)","title":"Header parameters"},{"location":"header/#multiple-header-parameters","text":"Note Header fields always use the simple style, that is, comma-separated values.","title":"Multiple Header Parameters"},{"location":"mode/","text":"Validation Modes The library provides two modes of operation for request validation: auto and manual . These modes determine how validation is applied to endpoints. auto Mode (Default) In auto mode, the library automatically validates the requests of all endpoints that have type hints in their function signatures. This mode simplifies development by eliminating the need for explicit configuration, ensuring that all typed routes are validated without additional effort. Key Features of auto Mode: Automatically validates all routes with type hints. Minimal configuration required. Suitable for most use cases where automatic validation is preferred. Example: import typing as t import annotated_types as at import flask import flask_typed_routes as ftr api = flask.Flask(__name__) ftr.FlaskTypedRoutes(api) # Default mode is 'auto' @api.get('/products/<int:product_id>/') def get_product(pk: t.Annotated[int, at.Gt(10)]): # The 'product_id' parameter is automatically validated as an integer. return flask.jsonify({\"product_id\": pk}) @api.get('/orders/<int:order_id>/') def get_order(order_id: t.Annotated[int, at.Gt(10)]): # The 'order_id' parameter is also automatically validated. return flask.jsonify({\"order_id\": order_id}) In this example, both get_product and get_order endpoints automatically validate the incoming parameters based on their type hints. manual Mode In manual mode, the user explicitly specifies which routes should be validated by applying the typed_route decorator. This mode provides greater control, allowing developers to selectively enable validation only where needed. Key Features of manual Mode: Validation is applied only to routes with the typed_route decorator. Offers granular control over validation. Useful for advanced use cases where not all routes require validation. How to Enable manual Mode: Set the mode to manual when initializing the library: import typing as t import annotated_types as at import flask import flask_typed_routes as ftr api = flask.Flask(__name__) ftr.FlaskTypedRoutes(api, mode=ftr.Mode.manual) @api.get('/products/<int:pk>/') @ftr.typed_route() # Validation is explicitly enabled for this route. def get_product(pk: t.Annotated[int, at.Gt(10)]): # The 'pk' parameter is validated as an integer. return flask.jsonify({\"pk\": pk}) @api.get('/orders/<int:order_id>/') def get_order(order_id: t.Annotated[int, at.Gt(10)]): # The 'order_id' parameter is NOT validated. return flask.jsonify({\"order_id\": order_id}) In this example: The get_product endpoint validates the pk parameter because the typed_route decorator is applied. The get_order endpoint does not validate the order_id parameter because it lacks the decorator. Summary Mode Validation Scope Use Case auto All endpoints with type hints Default, for seamless validation manual Only endpoints with typed_route decorator Advanced, for selective validation Choose the mode that best suits your project's needs. For most cases, auto mode provides a hassle-free experience, while manual mode allows for precise control over validation behavior.","title":"Validation Modes"},{"location":"mode/#validation-modes","text":"The library provides two modes of operation for request validation: auto and manual . These modes determine how validation is applied to endpoints.","title":"Validation Modes"},{"location":"mode/#auto-mode-default","text":"In auto mode, the library automatically validates the requests of all endpoints that have type hints in their function signatures. This mode simplifies development by eliminating the need for explicit configuration, ensuring that all typed routes are validated without additional effort.","title":"auto Mode (Default)"},{"location":"mode/#key-features-of-auto-mode","text":"Automatically validates all routes with type hints. Minimal configuration required. Suitable for most use cases where automatic validation is preferred.","title":"Key Features of auto Mode:"},{"location":"mode/#example","text":"import typing as t import annotated_types as at import flask import flask_typed_routes as ftr api = flask.Flask(__name__) ftr.FlaskTypedRoutes(api) # Default mode is 'auto' @api.get('/products/<int:product_id>/') def get_product(pk: t.Annotated[int, at.Gt(10)]): # The 'product_id' parameter is automatically validated as an integer. return flask.jsonify({\"product_id\": pk}) @api.get('/orders/<int:order_id>/') def get_order(order_id: t.Annotated[int, at.Gt(10)]): # The 'order_id' parameter is also automatically validated. return flask.jsonify({\"order_id\": order_id}) In this example, both get_product and get_order endpoints automatically validate the incoming parameters based on their type hints.","title":"Example:"},{"location":"mode/#manual-mode","text":"In manual mode, the user explicitly specifies which routes should be validated by applying the typed_route decorator. This mode provides greater control, allowing developers to selectively enable validation only where needed.","title":"manual Mode"},{"location":"mode/#key-features-of-manual-mode","text":"Validation is applied only to routes with the typed_route decorator. Offers granular control over validation. Useful for advanced use cases where not all routes require validation.","title":"Key Features of manual Mode:"},{"location":"mode/#how-to-enable-manual-mode","text":"Set the mode to manual when initializing the library: import typing as t import annotated_types as at import flask import flask_typed_routes as ftr api = flask.Flask(__name__) ftr.FlaskTypedRoutes(api, mode=ftr.Mode.manual) @api.get('/products/<int:pk>/') @ftr.typed_route() # Validation is explicitly enabled for this route. def get_product(pk: t.Annotated[int, at.Gt(10)]): # The 'pk' parameter is validated as an integer. return flask.jsonify({\"pk\": pk}) @api.get('/orders/<int:order_id>/') def get_order(order_id: t.Annotated[int, at.Gt(10)]): # The 'order_id' parameter is NOT validated. return flask.jsonify({\"order_id\": order_id}) In this example: The get_product endpoint validates the pk parameter because the typed_route decorator is applied. The get_order endpoint does not validate the order_id parameter because it lacks the decorator.","title":"How to Enable manual Mode:"},{"location":"mode/#summary","text":"Mode Validation Scope Use Case auto All endpoints with type hints Default, for seamless validation manual Only endpoints with typed_route decorator Advanced, for selective validation Choose the mode that best suits your project's needs. For most cases, auto mode provides a hassle-free experience, while manual mode allows for precise control over validation behavior.","title":"Summary"},{"location":"openapi/","text":"OpenApi This library automatically generates an OpenAPI schema based on the type annotations defined in the application's endpoints. In the examples, we will use the swagger-ui-py library to visualize the documentation generated by flask_typed_routes . The generated schema is fully customizable to meet the specific needs of your application. Additionally, the library offers the typed_route decorator, which enables fine-grained control over the various fields supported by OpenAPI to describe an operation. Detailed instructions on its usage can be found in the relevant sections of this documentation. Furthermore, the FlaskTypedRoutes class accepts keyword arguments (kwargs) corresponding to different OpenAPI configuration fields. These can be used to fully customize the application's schema and tailor it to specific requirements. Note The OpenAPI schema is generated automatically when the application is initialized. You can access the OpenAPI schema by calling the get_openapi_schema method of the FlaskTypedRoutes class. Warning Get the OpenAPI schema from the FlaskTypedRoutes instance after registering the routes and blueprints, as the extension first needs to collect the routes to generate the OpenAPI schema. Basic Usage Tip Ensure that the swagger-ui-py library is installed to visualize the OpenApi schema. pip install swagger-ui-py # ignore if already installed import flask import pydantic import swagger_ui import flask_typed_routes as ftr app = flask.Flask(__name__) app_ftr = ftr.FlaskTypedRoutes(app) class Item(pydantic.BaseModel): name: str description: str = None price: float @app.get('/items/<user>/') def read_items(user: str, skip: int = 0, limit: int = 10): data = {'user': user, 'skip': skip, 'limit': limit} return flask.jsonify(data) @app.post('/items/') def create_item(item: Item): return flask.jsonify(item.model_dump()) @app.put('/items/<item_id>/') def update_item(item_id: int, item: Item): return flask.jsonify({'item_id': item_id, **item.model_dump()}) @app.delete('/items/<item_id>/') def remove_item(item_id: int): return flask.jsonify({'item_id': item_id}) swagger_ui.api_doc(app, config=app_ftr.get_openapi_schema(), url_prefix='/docs') In this example if you run the application and navigate to http://127.0.0.1:5000/docs , you will see the documentation generated by the swagger-ui-py library using the OpenApi schema generated by flask_typed_routes . Using typed_route decorator The typed_route decorator allows you to parameterize the fields supported by OpenApi to describe an operation. import flask.views import swagger_ui import flask_typed_routes as ftr app = flask.Flask(__name__) app_ftr = ftr.FlaskTypedRoutes(app) @app.get('/items/<item_id>/') @ftr.typed_route( summary='Get item by ID', description='Get item by ID from the database by its ID.', tags=['items'], ) def get_item(item_id: int): return flask.jsonify({'item_id': item_id}) swagger_ui.api_doc(app, config=app_ftr.get_openapi_schema(), url_prefix='/docs') Customizing OpenAPI schema For more advanced customization, you can pass additional parameters to the FlaskTypedRoutes class. import flask.views import pydantic import swagger_ui import flask_typed_routes as ftr class Item(pydantic.BaseModel): name: str description: str = None price: float tax: float = None app = flask.Flask(__name__) app_ftr = ftr.FlaskTypedRoutes( app=app, openapi_version='3.1.1', title='My API', version='1.0.0', summary='This is a sample API', description='This is a sample API for demonstration purposes.', terms_of_service='https://example.com/terms/', contact_info={ 'name': 'API Support', 'url': 'http://www.example.com/support', 'email': 'support@gmail.com' }, license_info={ 'name': 'Apache 2.0', 'url': 'https://www.apache.org/licenses/LICENSE-2.0.html', }, servers=[{\"url\": \"/api/v3\"}], webhooks=None, tags=[ { \"name\": \"items\", \"description\": \"Everything about your items\", } ], components={ \"securitySchemes\": { 'item_auth': { \"type\": \"oauth2\", \"flows\": { \"implicit\": { \"authorizationUrl\": \"https://example.com/authorization\", \"scopes\": { \"read:items\": \"read items\", \"write:items\": \"write items\" } } } }, \"api_key\": { \"type\": \"apiKey\", \"name\": \"api_key\", \"in\": \"header\", } } }, external_docs={ \"description\": \"Find out more about Swagger\", \"url\": \"http://swagger.io\" }, ) @app.get('/items/<item_id>/') @ftr.typed_route( status_code=200, tags=['items'], summary='Get an item', description='Get an item by ID', security=[{'item_auth': ['read:items']}, {'api_key': []}] ) def read_item(item_id: int): return flask.jsonify({'item_id': item_id}) @app.put('/items/<item_id>/') @ftr.typed_route( status_code=202, tags=['items'], summary='Update an item', description='Update an item by ID', security=[{'item_auth': ['write:items']}] ) def update_item(item_id: int, item: Item): return flask.jsonify({'item_id': item_id, **item.model_dump()}) swagger_ui.api_doc( app, config=app_ftr.get_openapi_schema(), url_prefix='/docs' )","title":"OpenAPI"},{"location":"openapi/#openapi","text":"This library automatically generates an OpenAPI schema based on the type annotations defined in the application's endpoints. In the examples, we will use the swagger-ui-py library to visualize the documentation generated by flask_typed_routes . The generated schema is fully customizable to meet the specific needs of your application. Additionally, the library offers the typed_route decorator, which enables fine-grained control over the various fields supported by OpenAPI to describe an operation. Detailed instructions on its usage can be found in the relevant sections of this documentation. Furthermore, the FlaskTypedRoutes class accepts keyword arguments (kwargs) corresponding to different OpenAPI configuration fields. These can be used to fully customize the application's schema and tailor it to specific requirements. Note The OpenAPI schema is generated automatically when the application is initialized. You can access the OpenAPI schema by calling the get_openapi_schema method of the FlaskTypedRoutes class. Warning Get the OpenAPI schema from the FlaskTypedRoutes instance after registering the routes and blueprints, as the extension first needs to collect the routes to generate the OpenAPI schema.","title":"OpenApi"},{"location":"openapi/#basic-usage","text":"Tip Ensure that the swagger-ui-py library is installed to visualize the OpenApi schema. pip install swagger-ui-py # ignore if already installed import flask import pydantic import swagger_ui import flask_typed_routes as ftr app = flask.Flask(__name__) app_ftr = ftr.FlaskTypedRoutes(app) class Item(pydantic.BaseModel): name: str description: str = None price: float @app.get('/items/<user>/') def read_items(user: str, skip: int = 0, limit: int = 10): data = {'user': user, 'skip': skip, 'limit': limit} return flask.jsonify(data) @app.post('/items/') def create_item(item: Item): return flask.jsonify(item.model_dump()) @app.put('/items/<item_id>/') def update_item(item_id: int, item: Item): return flask.jsonify({'item_id': item_id, **item.model_dump()}) @app.delete('/items/<item_id>/') def remove_item(item_id: int): return flask.jsonify({'item_id': item_id}) swagger_ui.api_doc(app, config=app_ftr.get_openapi_schema(), url_prefix='/docs') In this example if you run the application and navigate to http://127.0.0.1:5000/docs , you will see the documentation generated by the swagger-ui-py library using the OpenApi schema generated by flask_typed_routes .","title":"Basic Usage"},{"location":"openapi/#using-typed_route-decorator","text":"The typed_route decorator allows you to parameterize the fields supported by OpenApi to describe an operation. import flask.views import swagger_ui import flask_typed_routes as ftr app = flask.Flask(__name__) app_ftr = ftr.FlaskTypedRoutes(app) @app.get('/items/<item_id>/') @ftr.typed_route( summary='Get item by ID', description='Get item by ID from the database by its ID.', tags=['items'], ) def get_item(item_id: int): return flask.jsonify({'item_id': item_id}) swagger_ui.api_doc(app, config=app_ftr.get_openapi_schema(), url_prefix='/docs')","title":"Using typed_route decorator"},{"location":"openapi/#customizing-openapi-schema","text":"For more advanced customization, you can pass additional parameters to the FlaskTypedRoutes class. import flask.views import pydantic import swagger_ui import flask_typed_routes as ftr class Item(pydantic.BaseModel): name: str description: str = None price: float tax: float = None app = flask.Flask(__name__) app_ftr = ftr.FlaskTypedRoutes( app=app, openapi_version='3.1.1', title='My API', version='1.0.0', summary='This is a sample API', description='This is a sample API for demonstration purposes.', terms_of_service='https://example.com/terms/', contact_info={ 'name': 'API Support', 'url': 'http://www.example.com/support', 'email': 'support@gmail.com' }, license_info={ 'name': 'Apache 2.0', 'url': 'https://www.apache.org/licenses/LICENSE-2.0.html', }, servers=[{\"url\": \"/api/v3\"}], webhooks=None, tags=[ { \"name\": \"items\", \"description\": \"Everything about your items\", } ], components={ \"securitySchemes\": { 'item_auth': { \"type\": \"oauth2\", \"flows\": { \"implicit\": { \"authorizationUrl\": \"https://example.com/authorization\", \"scopes\": { \"read:items\": \"read items\", \"write:items\": \"write items\" } } } }, \"api_key\": { \"type\": \"apiKey\", \"name\": \"api_key\", \"in\": \"header\", } } }, external_docs={ \"description\": \"Find out more about Swagger\", \"url\": \"http://swagger.io\" }, ) @app.get('/items/<item_id>/') @ftr.typed_route( status_code=200, tags=['items'], summary='Get an item', description='Get an item by ID', security=[{'item_auth': ['read:items']}, {'api_key': []}] ) def read_item(item_id: int): return flask.jsonify({'item_id': item_id}) @app.put('/items/<item_id>/') @ftr.typed_route( status_code=202, tags=['items'], summary='Update an item', description='Update an item by ID', security=[{'item_auth': ['write:items']}] ) def update_item(item_id: int, item: Item): return flask.jsonify({'item_id': item_id, **item.model_dump()}) swagger_ui.api_doc( app, config=app_ftr.get_openapi_schema(), url_prefix='/docs' )","title":"Customizing OpenAPI schema"},{"location":"path/","text":"Path Parameters You can validate Path parameters in your route by adding standard type hints to the function signature. flask_typed_routes ensures that parameters are correctly converted and validated based on their type annotations. Warning If no type hint is provided, the Path parameters are not validated. Basic Usage import typing as t import flask import flask_typed_routes as ftr app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) @app.route('/items/<category_id>/<lang>/') def read_items(category_id: int, lang: t.Literal['es', 'en']): data = {'category_id': category_id, 'lang': lang} return flask.jsonify(data) How It Works: category_id is automatically converted to an integer. lang is restricted to the values 'es' or 'en'. \u2705 Valid request GET http://127.0.0.1:5000/items/12/es { \"category_id\": 12, \"lang\": \"es\" } \u274c Bad request: (wrong type for category_id ) GET http://127.0.0.1:5000/items/abc/es { \"errors\": [ { \"input\": \"abc\", \"loc\": [ \"path\", \"category_id\" ], \"msg\": \"Input should be a valid integer, unable to parse string as an integer\", \"type\": \"int_parsing\", \"url\": \"https://errors.pydantic.dev/2.9/v/int_parsing\" } ] } Custom Validations You can apply additional validation using Pydantic's custom types with constraints, or define your own custom data types import typing as t import annotated_types as at import flask import flask_typed_routes as ftr app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) @app.route('/items/<category_id>/') def read_items(category_id: t.Annotated[int, at.Ge(1), at.Le(100)]): data = {'category_id': category_id} return flask.jsonify(data) Alternatively, you can use the Path field. This field is an extension of Pydantic's field , offering powerful validation capabilities. This flexibility allows you to tailor path parameter validation to your application's specific needs. import typing as t import flask import flask_typed_routes as ftr app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) @app.route('/items/<category_id>/') def read_items(category_id: t.Annotated[int, ftr.Path(ge=1, le=100)]): data = {'category_id': category_id} return flask.jsonify(data) Validation Rules: category_id must be an integer between 1 and 100. Aliasing Warning Aliases defined in Path type hints are ignored to maintain consistency with the Flask route parameter names. Arrays in Path Parameters Path parameters can be parsed as Arrays using set , tuple , or list . The library follows the simple style of OpenAPI parameter serialization for arrays, using commas as separators. Tip You can use the set type hint to validate that the values are unique. import flask import flask_typed_routes as ftr app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) @app.get('/users/<user_ids>/') def get_users(user_ids: list[int]): return flask.jsonify({'user_ids': user_ids}) Example request: GET http://127.0.0.1:5000/users/1,2,3/ { \"user_ids\": [1, 2, 3] } Objects in Path Parameters Path parameters can be parsed as Objects using dictionaries or Pydantic models. The library follows the simple style of OpenAPI parameter serialization for objects. Using a Dictionary: import flask import flask_typed_routes as ftr app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) @app.get('/users/<user_info>/') def get_users(user_info: dict[str, str]): return flask.jsonify({'user_info': user_info}) Example request: GET http://127.0.0.1:5000/users/role,admin,first_name,Alex { \"user_info\": { \"role\": \"admin\", \"first_name\": \"Alex\" } } Using a Pydantic model : import typing as t import flask import pydantic import flask_typed_routes as ftr app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) class User(pydantic.BaseModel): model_config = pydantic.ConfigDict(extra=\"forbid\") # Prevents extra fields name: str age: int = 100 @app.get('/users/<user_info>/') def get_users(user_info: t.Annotated[User, ftr.Path()]): return flask.jsonify({'user_info': user_info.model_dump()}) Example request: GET http://127.0.0.1:5000/users/name,Alex,age,25/ { \"user_info\": { \"age\": 25, \"name\": \"Alex\" } } Handling Extra Fields The extra=\"forbid\" configuration prevents additional fields: GET http://127.0.0.1:5000/users/name,Alex,age,25,role,Admin/ { \"errors\": [ { \"input\": \"Admin\", \"loc\": [ \"path\", \"user_info\", \"role\" ], \"msg\": \"Extra inputs are not permitted\", \"type\": \"extra_forbidden\", \"url\": \"https://errors.pydantic.dev/2.10/v/extra_forbidden\" } ] } Handling incomplete key-value pairs If the number of key-value pairs is not even, the library uses the last key as a key with an empty value, for example: GET 127.0.0.1:5000/users/name, { \"user_info\": { \"age\": 100, \"name\": \"\" } } Handling Exploded parameter With explode=True , keys and values are separated by = in the URL. import typing as t import flask import flask_typed_routes as ftr app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) @app.get('/users/<user_info>/') def get_users(user_info: t.Annotated[dict, ftr.Path(explode=True)]): return flask.jsonify({'user_info': user_info}) \u2705 Example Request GET http://127.0.0.1:5000/users/name=Alex,age=25,role=Admin { \"user_info\": { \"name\": \"Alex\", \"age\": \"25\", \"role\": \"Admin\" } } Incorrect Parsing If you pass explode=True , the library misinterprets this structure: \u274c GET http://127.0.0.1:5000/users/name,Alex,age,25,role,Admin/ The result is a dictionary with empty values because the library interprets the comma as a separator. { \"user_info\": { \"25\": \"\", \"Admin\": \"\", \"Alex\": \"\", \"age\": \"\", \"name\": \"\", \"role\": \"\" } }","title":"Path parameters"},{"location":"path/#path-parameters","text":"You can validate Path parameters in your route by adding standard type hints to the function signature. flask_typed_routes ensures that parameters are correctly converted and validated based on their type annotations. Warning If no type hint is provided, the Path parameters are not validated.","title":"Path Parameters"},{"location":"path/#basic-usage","text":"import typing as t import flask import flask_typed_routes as ftr app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) @app.route('/items/<category_id>/<lang>/') def read_items(category_id: int, lang: t.Literal['es', 'en']): data = {'category_id': category_id, 'lang': lang} return flask.jsonify(data) How It Works: category_id is automatically converted to an integer. lang is restricted to the values 'es' or 'en'. \u2705 Valid request GET http://127.0.0.1:5000/items/12/es { \"category_id\": 12, \"lang\": \"es\" } \u274c Bad request: (wrong type for category_id ) GET http://127.0.0.1:5000/items/abc/es { \"errors\": [ { \"input\": \"abc\", \"loc\": [ \"path\", \"category_id\" ], \"msg\": \"Input should be a valid integer, unable to parse string as an integer\", \"type\": \"int_parsing\", \"url\": \"https://errors.pydantic.dev/2.9/v/int_parsing\" } ] }","title":"Basic Usage"},{"location":"path/#custom-validations","text":"You can apply additional validation using Pydantic's custom types with constraints, or define your own custom data types import typing as t import annotated_types as at import flask import flask_typed_routes as ftr app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) @app.route('/items/<category_id>/') def read_items(category_id: t.Annotated[int, at.Ge(1), at.Le(100)]): data = {'category_id': category_id} return flask.jsonify(data) Alternatively, you can use the Path field. This field is an extension of Pydantic's field , offering powerful validation capabilities. This flexibility allows you to tailor path parameter validation to your application's specific needs. import typing as t import flask import flask_typed_routes as ftr app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) @app.route('/items/<category_id>/') def read_items(category_id: t.Annotated[int, ftr.Path(ge=1, le=100)]): data = {'category_id': category_id} return flask.jsonify(data) Validation Rules: category_id must be an integer between 1 and 100.","title":"Custom Validations"},{"location":"path/#aliasing","text":"Warning Aliases defined in Path type hints are ignored to maintain consistency with the Flask route parameter names.","title":"Aliasing"},{"location":"path/#arrays-in-path-parameters","text":"Path parameters can be parsed as Arrays using set , tuple , or list . The library follows the simple style of OpenAPI parameter serialization for arrays, using commas as separators. Tip You can use the set type hint to validate that the values are unique. import flask import flask_typed_routes as ftr app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) @app.get('/users/<user_ids>/') def get_users(user_ids: list[int]): return flask.jsonify({'user_ids': user_ids}) Example request: GET http://127.0.0.1:5000/users/1,2,3/ { \"user_ids\": [1, 2, 3] }","title":"Arrays in Path Parameters"},{"location":"path/#objects-in-path-parameters","text":"Path parameters can be parsed as Objects using dictionaries or Pydantic models. The library follows the simple style of OpenAPI parameter serialization for objects. Using a Dictionary: import flask import flask_typed_routes as ftr app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) @app.get('/users/<user_info>/') def get_users(user_info: dict[str, str]): return flask.jsonify({'user_info': user_info}) Example request: GET http://127.0.0.1:5000/users/role,admin,first_name,Alex { \"user_info\": { \"role\": \"admin\", \"first_name\": \"Alex\" } } Using a Pydantic model : import typing as t import flask import pydantic import flask_typed_routes as ftr app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) class User(pydantic.BaseModel): model_config = pydantic.ConfigDict(extra=\"forbid\") # Prevents extra fields name: str age: int = 100 @app.get('/users/<user_info>/') def get_users(user_info: t.Annotated[User, ftr.Path()]): return flask.jsonify({'user_info': user_info.model_dump()}) Example request: GET http://127.0.0.1:5000/users/name,Alex,age,25/ { \"user_info\": { \"age\": 25, \"name\": \"Alex\" } } Handling Extra Fields The extra=\"forbid\" configuration prevents additional fields: GET http://127.0.0.1:5000/users/name,Alex,age,25,role,Admin/ { \"errors\": [ { \"input\": \"Admin\", \"loc\": [ \"path\", \"user_info\", \"role\" ], \"msg\": \"Extra inputs are not permitted\", \"type\": \"extra_forbidden\", \"url\": \"https://errors.pydantic.dev/2.10/v/extra_forbidden\" } ] } Handling incomplete key-value pairs If the number of key-value pairs is not even, the library uses the last key as a key with an empty value, for example: GET 127.0.0.1:5000/users/name, { \"user_info\": { \"age\": 100, \"name\": \"\" } } Handling Exploded parameter With explode=True , keys and values are separated by = in the URL. import typing as t import flask import flask_typed_routes as ftr app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) @app.get('/users/<user_info>/') def get_users(user_info: t.Annotated[dict, ftr.Path(explode=True)]): return flask.jsonify({'user_info': user_info}) \u2705 Example Request GET http://127.0.0.1:5000/users/name=Alex,age=25,role=Admin { \"user_info\": { \"name\": \"Alex\", \"age\": \"25\", \"role\": \"Admin\" } } Incorrect Parsing If you pass explode=True , the library misinterprets this structure: \u274c GET http://127.0.0.1:5000/users/name,Alex,age,25,role,Admin/ The result is a dictionary with empty values because the library interprets the comma as a separator. { \"user_info\": { \"25\": \"\", \"Admin\": \"\", \"Alex\": \"\", \"age\": \"\", \"name\": \"\", \"role\": \"\" } }","title":"Objects in Path Parameters"},{"location":"query/","text":"Query parameters Parameters not included in the Path are automatically treated as Query parameters. Required: Declared as function arguments without default values. Optional: Declared with default values. import flask import flask_typed_routes as ftr app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) @app.route('/items/') def get_items(needy: str, skip: int = 0, limit: int = 100): data = { 'needy': needy, 'skip': skip, 'limit': limit, } return flask.jsonify(data) Validation: needy : Required and must be a string. skip : Optional and must be an integer. If not included, it defaults to 0. limit : Optional and must be an integer. If not included, it defaults to 100. \u2705 Valid request: GET http://127.0.0.1:5000/items/?needy=passed&skip=20 { \"limit\": 100, \"needy\": \"passed\", \"skip\": 20 } \u274c Bad request: If needy is not included in the request http://127.0.0.1:5000/items/ { \"errors\": [ { \"input\": {}, \"loc\": [ \"query\", \"needy\" ], \"msg\": \"Field required\", \"type\": \"missing\", \"url\": \"https://errors.pydantic.dev/2.9/v/missing\" } ] } Custom validations You can apply additional validation using Pydantic's custom types with constraints, or define your own custom data types import typing as t import annotated_types as at import flask import pydantic import flask_typed_routes as ftr app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) # Custom Types for additional validation combining Pydantic and Annotated Needy = t.Annotated[str, at.MinLen(3), at.MaxLen(10)] Limit = t.Annotated[int, at.Ge(1), at.Le(100), pydantic.Field(alias=\"size\")] @app.route('/items/') def get_items(needy: Needy, skip: int = 0, limit: Limit = 100): data = { 'needy': needy, 'skip': skip, 'limit': limit, } return flask.jsonify(data) Alternatively, you can use the Query field. This field is an extension of Pydantic's field , offering powerful validation capabilities. This flexibility allows you to tailor query parameter validation to your application's specific needs. Tip The Query field is supported aliasing. You can use the alias argument to define the query parameter name in the request. import typing as t import flask import flask_typed_routes as ftr app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) Needy = t.Annotated[str, ftr.Query(min_length=3, max_length=10)] Limit = t.Annotated[int, ftr.Query(ge=1, le=100, alias=\"size\")] @app.route('/items/') def get_items(needy: Needy, skip: int = 0, limit: Limit = 100): data = { 'needy': needy, 'skip': skip, 'limit': limit, } return flask.jsonify(data) Validation: needy : Required and must be a string between 3 and 10 characters. skip : Optional and must be an integer. limit : Optional and must be an integer between 1 and 100, and must be named size in the request. Example request: GET http://127.0.0.1:5000/items/?needy=passed&size=20 { \"limit\": 20, \"needy\": \"passed\", \"skip\": 0 } Pydantic models If you have a group of query parameters that are related, you can create a Pydantic model to declare them. This would allow you to re-use the model in multiple places and also to declare validations and metadata for all the parameters at once. import typing as t import pydantic import flask import flask_typed_routes as ftr app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) class QueryParams(pydantic.BaseModel): status: bool skip: int = 0 limit: int = 10 tracking_number: t.Annotated[int, pydantic.Field(alias=\"tracking\", le=3)] = 1 payment_method: t.Literal[\"cash\", \"credit\"] = \"credit\" @app.get('/orders/<user_id>/') def get_orders( user_id: int, params: t.Annotated[QueryParams, ftr.Query()] ): data = {'user_id': user_id, \"params\": params.model_dump()} return flask.jsonify(data) Warning The Query field can only be directly specified in the function signature . When using Pydantic models, you must use Pydantic's fields . Example request: GET ttp://127.0.0.1:5000/orders/233/?status=true { \"params\": { \"limit\": 10, \"payment_method\": \"credit\", \"skip\": 0, \"status\": true, \"tracking_number\": 1 }, \"user_id\": 233 } Arrays in query parameters If you want to allow a query parameter to parse as an Array , you can use set , tuple , or list annotations. Tip You can use the set type hint to validate that the values are unique. import typing as t import flask import flask_typed_routes as ftr import pydantic app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) Tags = t.Annotated[list[str], pydantic.Field(alias=\"tag\")] @app.get('/users/<user_id>/') def get_users(user_id: int, tags: Tags = ()): data = {'user_id': user_id, \"tags\": tags} return flask.jsonify(data) Example request: GET http://127.0.0.1:5000/users/123/?tag=hello&tag=world { \"tags\": [ \"hello\", \"world\" ], \"user_id\": 123 } Note It is important to highlight that the previous URL contains multiple query parameters named tag . Tip If the URL includes a query parameter with multiple values separated by commas, pipes( | ), or spaces, the resulting list will contain a single element with the entire string. To retrieve each value separately, you need to set the explode parameter in the Query field and specify the style parameter to define the serialization format. Here\u2019s an example of how to do it: import typing as t import flask import flask_typed_routes as ftr app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) # By default, the 'style' is 'form', which means that the values are separated by commas. TagsByComma = t.Annotated[list[str], ftr.Query(explode=False)] # You can also use 'pipeDelimited' or 'spaceDelimited' as the 'style' to indicate another serialization style delimiter. TagsBySpace = t.Annotated[list[str], ftr.Query(explode=False, style=\"spaceDelimited\")] TagsByPipe = t.Annotated[list[str], ftr.Query(explode=False, style=\"pipeDelimited\")] @app.get('/tags/comma/') def get_tags_by_comma(tags: TagsByComma = ()): return flask.jsonify({\"tags\": tags}) @app.get('/tags/space/') def get_tags_by_space(tags: TagsBySpace = ()): return flask.jsonify({\"tags\": tags}) @app.get('/tags/pipe/') def get_tags_by_pipe(tags: TagsByPipe = ()): return flask.jsonify({\"tags\": tags}) Example requests: By commas: http://localhost:5000/tags/comma/?tags=hello,world By spaces: http://localhost:5000/tags/space/?tags=hello world By pipes: http://localhost:5000/tags/pipe/?tags=hello|world You will see the JSON response as: { \"tags\": [ \"hello\", \"world\" ] } Object in a single query parameter Query parameters can be parsed as Objects using dictionaries or Pydantic models. The library follows the form style and of OpenAPI parameter serialization for objects. The default serialization method is: Style: form Explode: true The query parameter info is serialized as follows: style explode URL form false /users?info=role,admin,first_name,Alex pipeDelimited true/false n/a pipeDelimited true/false n/a You can use dict or Pydantic models to parse object query parameters. Using a dictionary import typing as t import flask import flask_typed_routes as ftr app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) @app.get('/users/') def get_users(info: t.Annotated[dict, ftr.Query(explode=False)]): return flask.jsonify({'info': info}) Example request: GET http://127.0.0.1:5000/users/?info=role,admin,first_name,Alex { \"info\": { \"first_name\": \"Alex\", \"role\": \"admin\" } } Using Pydantic models : In this example, we use a Pydantic model to parse the query parameters and an embedded model to interpret the info query parameter as an object using explode=False with form=style . The explode is set to false to parse the query parameter as an object, while the style defaults to form . The supported styles are form , spaceDelimited , and pipeDelimited , but only form is supported for objects. import typing as t import flask import pydantic import flask_typed_routes as ftr app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) class UserInfo(pydantic.BaseModel): role: str first_name: str class QueryParams(pydantic.BaseModel): info: UserInfo @app.get('/users/') def get_users(info: t.Annotated[QueryParams, ftr.Query(explode=False)]): return flask.jsonify({'info': info.model_dump()}) Example request: GET http://127.0.0.1:5000/users/?info=role,admin,first_name,Alex { \"info\": { \"first_name\": \"Alex\", \"role\": \"admin\" } }","title":"Query parameters"},{"location":"query/#query-parameters","text":"Parameters not included in the Path are automatically treated as Query parameters. Required: Declared as function arguments without default values. Optional: Declared with default values. import flask import flask_typed_routes as ftr app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) @app.route('/items/') def get_items(needy: str, skip: int = 0, limit: int = 100): data = { 'needy': needy, 'skip': skip, 'limit': limit, } return flask.jsonify(data) Validation: needy : Required and must be a string. skip : Optional and must be an integer. If not included, it defaults to 0. limit : Optional and must be an integer. If not included, it defaults to 100. \u2705 Valid request: GET http://127.0.0.1:5000/items/?needy=passed&skip=20 { \"limit\": 100, \"needy\": \"passed\", \"skip\": 20 } \u274c Bad request: If needy is not included in the request http://127.0.0.1:5000/items/ { \"errors\": [ { \"input\": {}, \"loc\": [ \"query\", \"needy\" ], \"msg\": \"Field required\", \"type\": \"missing\", \"url\": \"https://errors.pydantic.dev/2.9/v/missing\" } ] }","title":"Query parameters"},{"location":"query/#custom-validations","text":"You can apply additional validation using Pydantic's custom types with constraints, or define your own custom data types import typing as t import annotated_types as at import flask import pydantic import flask_typed_routes as ftr app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) # Custom Types for additional validation combining Pydantic and Annotated Needy = t.Annotated[str, at.MinLen(3), at.MaxLen(10)] Limit = t.Annotated[int, at.Ge(1), at.Le(100), pydantic.Field(alias=\"size\")] @app.route('/items/') def get_items(needy: Needy, skip: int = 0, limit: Limit = 100): data = { 'needy': needy, 'skip': skip, 'limit': limit, } return flask.jsonify(data) Alternatively, you can use the Query field. This field is an extension of Pydantic's field , offering powerful validation capabilities. This flexibility allows you to tailor query parameter validation to your application's specific needs. Tip The Query field is supported aliasing. You can use the alias argument to define the query parameter name in the request. import typing as t import flask import flask_typed_routes as ftr app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) Needy = t.Annotated[str, ftr.Query(min_length=3, max_length=10)] Limit = t.Annotated[int, ftr.Query(ge=1, le=100, alias=\"size\")] @app.route('/items/') def get_items(needy: Needy, skip: int = 0, limit: Limit = 100): data = { 'needy': needy, 'skip': skip, 'limit': limit, } return flask.jsonify(data) Validation: needy : Required and must be a string between 3 and 10 characters. skip : Optional and must be an integer. limit : Optional and must be an integer between 1 and 100, and must be named size in the request. Example request: GET http://127.0.0.1:5000/items/?needy=passed&size=20 { \"limit\": 20, \"needy\": \"passed\", \"skip\": 0 }","title":"Custom validations"},{"location":"query/#pydantic-models","text":"If you have a group of query parameters that are related, you can create a Pydantic model to declare them. This would allow you to re-use the model in multiple places and also to declare validations and metadata for all the parameters at once. import typing as t import pydantic import flask import flask_typed_routes as ftr app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) class QueryParams(pydantic.BaseModel): status: bool skip: int = 0 limit: int = 10 tracking_number: t.Annotated[int, pydantic.Field(alias=\"tracking\", le=3)] = 1 payment_method: t.Literal[\"cash\", \"credit\"] = \"credit\" @app.get('/orders/<user_id>/') def get_orders( user_id: int, params: t.Annotated[QueryParams, ftr.Query()] ): data = {'user_id': user_id, \"params\": params.model_dump()} return flask.jsonify(data) Warning The Query field can only be directly specified in the function signature . When using Pydantic models, you must use Pydantic's fields . Example request: GET ttp://127.0.0.1:5000/orders/233/?status=true { \"params\": { \"limit\": 10, \"payment_method\": \"credit\", \"skip\": 0, \"status\": true, \"tracking_number\": 1 }, \"user_id\": 233 }","title":"Pydantic models"},{"location":"query/#arrays-in-query-parameters","text":"If you want to allow a query parameter to parse as an Array , you can use set , tuple , or list annotations. Tip You can use the set type hint to validate that the values are unique. import typing as t import flask import flask_typed_routes as ftr import pydantic app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) Tags = t.Annotated[list[str], pydantic.Field(alias=\"tag\")] @app.get('/users/<user_id>/') def get_users(user_id: int, tags: Tags = ()): data = {'user_id': user_id, \"tags\": tags} return flask.jsonify(data) Example request: GET http://127.0.0.1:5000/users/123/?tag=hello&tag=world { \"tags\": [ \"hello\", \"world\" ], \"user_id\": 123 } Note It is important to highlight that the previous URL contains multiple query parameters named tag . Tip If the URL includes a query parameter with multiple values separated by commas, pipes( | ), or spaces, the resulting list will contain a single element with the entire string. To retrieve each value separately, you need to set the explode parameter in the Query field and specify the style parameter to define the serialization format. Here\u2019s an example of how to do it: import typing as t import flask import flask_typed_routes as ftr app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) # By default, the 'style' is 'form', which means that the values are separated by commas. TagsByComma = t.Annotated[list[str], ftr.Query(explode=False)] # You can also use 'pipeDelimited' or 'spaceDelimited' as the 'style' to indicate another serialization style delimiter. TagsBySpace = t.Annotated[list[str], ftr.Query(explode=False, style=\"spaceDelimited\")] TagsByPipe = t.Annotated[list[str], ftr.Query(explode=False, style=\"pipeDelimited\")] @app.get('/tags/comma/') def get_tags_by_comma(tags: TagsByComma = ()): return flask.jsonify({\"tags\": tags}) @app.get('/tags/space/') def get_tags_by_space(tags: TagsBySpace = ()): return flask.jsonify({\"tags\": tags}) @app.get('/tags/pipe/') def get_tags_by_pipe(tags: TagsByPipe = ()): return flask.jsonify({\"tags\": tags}) Example requests: By commas: http://localhost:5000/tags/comma/?tags=hello,world By spaces: http://localhost:5000/tags/space/?tags=hello world By pipes: http://localhost:5000/tags/pipe/?tags=hello|world You will see the JSON response as: { \"tags\": [ \"hello\", \"world\" ] }","title":"Arrays in query parameters"},{"location":"query/#object-in-a-single-query-parameter","text":"Query parameters can be parsed as Objects using dictionaries or Pydantic models. The library follows the form style and of OpenAPI parameter serialization for objects. The default serialization method is: Style: form Explode: true The query parameter info is serialized as follows: style explode URL form false /users?info=role,admin,first_name,Alex pipeDelimited true/false n/a pipeDelimited true/false n/a You can use dict or Pydantic models to parse object query parameters. Using a dictionary import typing as t import flask import flask_typed_routes as ftr app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) @app.get('/users/') def get_users(info: t.Annotated[dict, ftr.Query(explode=False)]): return flask.jsonify({'info': info}) Example request: GET http://127.0.0.1:5000/users/?info=role,admin,first_name,Alex { \"info\": { \"first_name\": \"Alex\", \"role\": \"admin\" } } Using Pydantic models : In this example, we use a Pydantic model to parse the query parameters and an embedded model to interpret the info query parameter as an object using explode=False with form=style . The explode is set to false to parse the query parameter as an object, while the style defaults to form . The supported styles are form , spaceDelimited , and pipeDelimited , but only form is supported for objects. import typing as t import flask import pydantic import flask_typed_routes as ftr app = flask.Flask(__name__) ftr.FlaskTypedRoutes(app) class UserInfo(pydantic.BaseModel): role: str first_name: str class QueryParams(pydantic.BaseModel): info: UserInfo @app.get('/users/') def get_users(info: t.Annotated[QueryParams, ftr.Query(explode=False)]): return flask.jsonify({'info': info.model_dump()}) Example request: GET http://127.0.0.1:5000/users/?info=role,admin,first_name,Alex { \"info\": { \"first_name\": \"Alex\", \"role\": \"admin\" } }","title":"Object in a single query parameter"}]}