{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"About flask_typed_routes is a Python library designed to validate Flask requests effortlessly with Pydantic . Features Type Safety: Automatically validates request parameters based on type annotations. Easy Integration: Simple decorator syntax for applying validation to Flask routes. Error Handling: Automatically returns meaningful error responses for validation failures. Requirements Python 3.10+ Pydantic 2.0+ Flask Installation To install flask_typed_routes using pip , run the following command: pip install flask_typed_routes Getting Started Example of a simple Flask application using flask_typed_routes : Create a file posts.py with: import flask import flask_typed_routes as flask_tpr app = flask.Flask(__name__) flask_tpr.FlaskTypeRoutes(app) @app.route('/posts/<user>/') @flask_tpr.typed_route def read_user_posts(user: str, skip: int = 0, limit: int = 10): # Parameters not included in the \"path\" are automatically treated as \"query\" parameters. data = { 'user': user, 'skip': skip, 'limit': limit, } return flask.jsonify(data) Run the server with: flask --app posts run Data conversion: Open your browser and go to http://127.0.0.1:5000/posts/myuser/?skip=20 You will see the JSON response as: { \"limit\": 10, \"skip\": 20, \"user\": \"myuser\" } Data validation: Open your browser and go to http://127.0.0.1:5000/posts/myuser/?skip=abc You will see the JSON response with the error details because the skip parameter is not an integer: { \"errors\": [ { \"input\": \"abc\", \"loc\": [ \"query\", \"skip\" ], \"msg\": \"Input should be a valid integer, unable to parse string as an integer\", \"type\": \"int_parsing\", \"url\": \"https://errors.pydantic.dev/2.9/v/int_parsing\" } ] }","title":"Introduction"},{"location":"#about","text":"flask_typed_routes is a Python library designed to validate Flask requests effortlessly with Pydantic .","title":"About"},{"location":"#features","text":"Type Safety: Automatically validates request parameters based on type annotations. Easy Integration: Simple decorator syntax for applying validation to Flask routes. Error Handling: Automatically returns meaningful error responses for validation failures.","title":"Features"},{"location":"#requirements","text":"Python 3.10+ Pydantic 2.0+ Flask","title":"Requirements"},{"location":"#installation","text":"To install flask_typed_routes using pip , run the following command: pip install flask_typed_routes","title":"Installation"},{"location":"#getting-started","text":"Example of a simple Flask application using flask_typed_routes : Create a file posts.py with: import flask import flask_typed_routes as flask_tpr app = flask.Flask(__name__) flask_tpr.FlaskTypeRoutes(app) @app.route('/posts/<user>/') @flask_tpr.typed_route def read_user_posts(user: str, skip: int = 0, limit: int = 10): # Parameters not included in the \"path\" are automatically treated as \"query\" parameters. data = { 'user': user, 'skip': skip, 'limit': limit, } return flask.jsonify(data) Run the server with: flask --app posts run Data conversion: Open your browser and go to http://127.0.0.1:5000/posts/myuser/?skip=20 You will see the JSON response as: { \"limit\": 10, \"skip\": 20, \"user\": \"myuser\" } Data validation: Open your browser and go to http://127.0.0.1:5000/posts/myuser/?skip=abc You will see the JSON response with the error details because the skip parameter is not an integer: { \"errors\": [ { \"input\": \"abc\", \"loc\": [ \"query\", \"skip\" ], \"msg\": \"Input should be a valid integer, unable to parse string as an integer\", \"type\": \"int_parsing\", \"url\": \"https://errors.pydantic.dev/2.9/v/int_parsing\" } ] }","title":"Getting Started"},{"location":"body/","text":"Request Body To declare a request body, you use Pydantic models with all their power and benefits The library provides annotations like JsonBody() to validate specific fields in the request body. Basic Usage of request Body Validation: import typing as t import flask import pydantic import flask_typed_routes as flask_tpr app = flask.Flask(__name__) flask_tpr.FlaskTypeRoutes(app) class Post(pydantic.BaseModel): title: str author: str @app.post('/posts/') @flask_tpr.typed_route def create_post(post: Post): return flask.jsonify(post.model_dump()) @app.put('/posts/<post_id>/') @flask_tpr.typed_route def update_post( post_id: int, title: t.Annotated[str, flask_tpr.JsonBody()] = None, author: t.Annotated[str, flask_tpr.JsonBody()] = None, ): data = { 'post_id': post_id, 'title': title, 'author': author, } return flask.jsonify(data) Explanation: Post : Pydantic model that represents the structure of the request body. The model has two fields: title and author . create_post : Route that accepts a POST request with a JSON body that must match the Post model. update_post : Route that accepts a URL parameter post_id that must be an integer. The route also accepts two optional JSON body parameters: title and author . The parameters are validated using the library field JsonBody . Create a new POST Invalid request Body: http://127.0.0.1:5000/posts/ { \"title\": \"Hello, World!\" } Http Response: { \"errors\": [ { \"input\": { \"title\": \"Hello, World!\" }, \"loc\": [ \"body\", \"author\" ], \"msg\": \"Field required\", \"type\": \"missing\", \"url\": \"https://errors.pydantic.dev/2.9/v/missing\" } ] } Update a POST Invalid request Body: http://127.0.0.1:5000/posts/123 { \"title\": 111 } Http Response: { \"errors\": [ { \"input\": 111, \"loc\": [ \"body\", \"title\" ], \"msg\": \"Input should be a valid string\", \"type\": \"string_type\", \"url\": \"https://errors.pydantic.dev/2.9/v/string_type\" } ] }","title":"Request body"},{"location":"body/#request-body","text":"To declare a request body, you use Pydantic models with all their power and benefits The library provides annotations like JsonBody() to validate specific fields in the request body. Basic Usage of request Body Validation: import typing as t import flask import pydantic import flask_typed_routes as flask_tpr app = flask.Flask(__name__) flask_tpr.FlaskTypeRoutes(app) class Post(pydantic.BaseModel): title: str author: str @app.post('/posts/') @flask_tpr.typed_route def create_post(post: Post): return flask.jsonify(post.model_dump()) @app.put('/posts/<post_id>/') @flask_tpr.typed_route def update_post( post_id: int, title: t.Annotated[str, flask_tpr.JsonBody()] = None, author: t.Annotated[str, flask_tpr.JsonBody()] = None, ): data = { 'post_id': post_id, 'title': title, 'author': author, } return flask.jsonify(data) Explanation: Post : Pydantic model that represents the structure of the request body. The model has two fields: title and author . create_post : Route that accepts a POST request with a JSON body that must match the Post model. update_post : Route that accepts a URL parameter post_id that must be an integer. The route also accepts two optional JSON body parameters: title and author . The parameters are validated using the library field JsonBody .","title":"Request Body"},{"location":"body/#create-a-new-post","text":"Invalid request Body: http://127.0.0.1:5000/posts/ { \"title\": \"Hello, World!\" } Http Response: { \"errors\": [ { \"input\": { \"title\": \"Hello, World!\" }, \"loc\": [ \"body\", \"author\" ], \"msg\": \"Field required\", \"type\": \"missing\", \"url\": \"https://errors.pydantic.dev/2.9/v/missing\" } ] }","title":"Create a new POST"},{"location":"body/#update-a-post","text":"Invalid request Body: http://127.0.0.1:5000/posts/123 { \"title\": 111 } Http Response: { \"errors\": [ { \"input\": 111, \"loc\": [ \"body\", \"title\" ], \"msg\": \"Input should be a valid string\", \"type\": \"string_type\", \"url\": \"https://errors.pydantic.dev/2.9/v/string_type\" } ] }","title":"Update a POST"},{"location":"cookie/","text":"Documentation Under Development !!!","title":"Cookie parameters"},{"location":"errors/","text":"Documentation Under Development !!!","title":"Handling errors"},{"location":"header/","text":"Documentation Under Development !!!","title":"Header parameters"},{"location":"path/","text":"Path Parameters This section demonstrates how to use the library to validate and enforce types for path parameters in your Flask application. import typing as t import flask import flask_typed_routes as flask_tpr app = flask.Flask(__name__) flask_tpr.FlaskTypeRoutes(app) @app.route('/posts/<user_id>/<country_iso>') @flask_tpr.typed_route def read_posts(user_id: int, country_iso: t.Annotated[str, flask_tpr.Path(max_length=2)]): data = { 'user_id': user_id, 'country_iso': country_iso, } return flask.jsonify(data) Validations: user_id: Must be an integer. country_iso: Must be a string with a maximum length of 2 characters. This parameter is validated using the libray field Path . Valid Request: http://127.0.0.1:5000/posts/12/ES { \"country_iso\": \"ES\", \"user_id\": 12 } Invalid Requests: Case1 If \"user_id\" is not an integer: http://127.0.0.1:5000/posts/abc/ES { \"errors\": [ { \"input\": \"abc\", \"loc\": [ \"path\", \"user_id\" ], \"msg\": \"Input should be a valid integer, unable to parse string as an integer\", \"type\": \"int_parsing\", \"url\": \"https://errors.pydantic.dev/2.9/v/int_parsing\" } ] } Case2 If \"country_iso\" is not a string with a maximum length of 2 characters: http://127.0.0.1:5000/posts/12/ESP { \"errors\": [ { \"ctx\": { \"max_length\": 2 }, \"input\": \"ESP\", \"loc\": [ \"path\", \"country_iso\" ], \"msg\": \"String should have at most 2 characters\", \"type\": \"string_too_long\", \"url\": \"https://errors.pydantic.dev/2.9/v/string_too_long\" } ] } Custom Path Validations The Path field is an extension of Pydantic's field, offering powerful validation capabilities. This flexibility allows you to tailor path parameter validation to your application's specific needs.","title":"Path parameters"},{"location":"path/#path-parameters","text":"This section demonstrates how to use the library to validate and enforce types for path parameters in your Flask application. import typing as t import flask import flask_typed_routes as flask_tpr app = flask.Flask(__name__) flask_tpr.FlaskTypeRoutes(app) @app.route('/posts/<user_id>/<country_iso>') @flask_tpr.typed_route def read_posts(user_id: int, country_iso: t.Annotated[str, flask_tpr.Path(max_length=2)]): data = { 'user_id': user_id, 'country_iso': country_iso, } return flask.jsonify(data) Validations: user_id: Must be an integer. country_iso: Must be a string with a maximum length of 2 characters. This parameter is validated using the libray field Path . Valid Request: http://127.0.0.1:5000/posts/12/ES { \"country_iso\": \"ES\", \"user_id\": 12 } Invalid Requests: Case1 If \"user_id\" is not an integer: http://127.0.0.1:5000/posts/abc/ES { \"errors\": [ { \"input\": \"abc\", \"loc\": [ \"path\", \"user_id\" ], \"msg\": \"Input should be a valid integer, unable to parse string as an integer\", \"type\": \"int_parsing\", \"url\": \"https://errors.pydantic.dev/2.9/v/int_parsing\" } ] } Case2 If \"country_iso\" is not a string with a maximum length of 2 characters: http://127.0.0.1:5000/posts/12/ESP { \"errors\": [ { \"ctx\": { \"max_length\": 2 }, \"input\": \"ESP\", \"loc\": [ \"path\", \"country_iso\" ], \"msg\": \"String should have at most 2 characters\", \"type\": \"string_too_long\", \"url\": \"https://errors.pydantic.dev/2.9/v/string_too_long\" } ] } Custom Path Validations The Path field is an extension of Pydantic's field, offering powerful validation capabilities. This flexibility allows you to tailor path parameter validation to your application's specific needs.","title":"Path Parameters"},{"location":"query/","text":"Query parameters Parameters not included in the \"path\" are automatically treated as \"query\" parameters. import typing as t import flask import flask_typed_routes as flask_tpr app = flask.Flask(__name__) flask_tpr.FlaskTypeRoutes(app) @app.route('/posts/') @flask_tpr.typed_route def read_posts(needy: str, skip: int = 0, limit: t.Annotated[int, flask_tpr.Query(alias=\"max\", le=100)] = 100): data = { 'needy': needy, 'skip': skip, 'limit': limit, } return flask.jsonify(data) Explanation: needy : Query parameter that must be included in the request and must be a string. skip : Query parameter that is optional and must be an integer. If not included, it defaults to 0. limit : Query parameter that is optional and must be a string. If not included, it defaults to 100. The parameter is validated using the library field Query with a maximum value of 100. The parameter is also aliased as max . Note: The alias is used to demonstrate how the library can support Pydantic's Field class. Valid Request: http://127.0.0.1:5000/posts/?needy=passed&max=20 { \"limit\": 20, \"needy\": \"passed\", \"skip\": 0 } Invalid Requests: Case1 If \"needy\" is not included in the request: http://127.0.0.1:5000/posts/ { \"errors\": [ { \"input\": {}, \"loc\": [ \"query\", \"needy\" ], \"msg\": \"Field required\", \"type\": \"missing\", \"url\": \"https://errors.pydantic.dev/2.9/v/missing\" } ] } Case2 If \"limit\" (alias: \"max\") is greater than 100: http://127.0.0.1:5000/posts/?needy=passed&max=1000 { \"errors\": [ { \"ctx\": { \"le\": 100 }, \"input\": \"1000\", \"loc\": [ \"query\", \"max\" ], \"msg\": \"Input should be less than or equal to 100\", \"type\": \"less_than_equal\", \"url\": \"https://errors.pydantic.dev/2.9/v/less_than_equal\" } ] }","title":"Query parameters"},{"location":"query/#query-parameters","text":"Parameters not included in the \"path\" are automatically treated as \"query\" parameters. import typing as t import flask import flask_typed_routes as flask_tpr app = flask.Flask(__name__) flask_tpr.FlaskTypeRoutes(app) @app.route('/posts/') @flask_tpr.typed_route def read_posts(needy: str, skip: int = 0, limit: t.Annotated[int, flask_tpr.Query(alias=\"max\", le=100)] = 100): data = { 'needy': needy, 'skip': skip, 'limit': limit, } return flask.jsonify(data) Explanation: needy : Query parameter that must be included in the request and must be a string. skip : Query parameter that is optional and must be an integer. If not included, it defaults to 0. limit : Query parameter that is optional and must be a string. If not included, it defaults to 100. The parameter is validated using the library field Query with a maximum value of 100. The parameter is also aliased as max . Note: The alias is used to demonstrate how the library can support Pydantic's Field class. Valid Request: http://127.0.0.1:5000/posts/?needy=passed&max=20 { \"limit\": 20, \"needy\": \"passed\", \"skip\": 0 } Invalid Requests: Case1 If \"needy\" is not included in the request: http://127.0.0.1:5000/posts/ { \"errors\": [ { \"input\": {}, \"loc\": [ \"query\", \"needy\" ], \"msg\": \"Field required\", \"type\": \"missing\", \"url\": \"https://errors.pydantic.dev/2.9/v/missing\" } ] } Case2 If \"limit\" (alias: \"max\") is greater than 100: http://127.0.0.1:5000/posts/?needy=passed&max=1000 { \"errors\": [ { \"ctx\": { \"le\": 100 }, \"input\": \"1000\", \"loc\": [ \"query\", \"max\" ], \"msg\": \"Input should be less than or equal to 100\", \"type\": \"less_than_equal\", \"url\": \"https://errors.pydantic.dev/2.9/v/less_than_equal\" } ] }","title":"Query parameters"}]}